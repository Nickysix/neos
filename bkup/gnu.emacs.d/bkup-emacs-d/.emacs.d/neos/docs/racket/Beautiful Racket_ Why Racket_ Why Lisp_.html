<!DOCTYPE html>
<!-- saved from url=(0061)https://beautifulracket.com/appendix/why-racket-why-lisp.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Beautiful Racket: Why Racket? Why Lisp?</title>
    <link rel="stylesheet" type="text/css" media="all" href="./Beautiful Racket_ Why Racket_ Why Lisp__files/styles.css">
    <script type="text/javascript" src="./Beautiful Racket_ Why Racket_ Why Lisp__files/functions.js"></script><style id="dark-reader-style" type="text/css">@media screen {

/* Leading rule */
html {
  -webkit-filter: invert(100%) hue-rotate(180deg) brightness(70%) contrast(90%) !important;
  filter: invert(100%) hue-rotate(180deg) brightness(70%) contrast(90%) !important;
}

/* Reverse rule */
img,
video,
:not(object):not(body)>embed,
object,
svg image,
[style*="background:url"],
[style*="background-image:url"],
[style*="background: url"],
[style*="background-image: url"],
[background],
twitterwidget {
  -webkit-filter: invert(100%) hue-rotate(180deg) !important;
  filter: invert(100%) hue-rotate(180deg) !important;
}
[style*="background:url"] *,
[style*="background-image:url"] *,
[style*="background: url"] *,
[style*="background-image: url"] *,
input,
[background] *,
img[src^="https://s0.wp.com/latex.php"],
twitterwidget .NaturalImage-image {
  -webkit-filter: none !important;
  filter: none !important;
}
.compatibility-with-darkreader-below-4-3-3 {
  background: white !important;
}

/* Text contrast */
html {
  text-shadow: 0 0 0 !important;
}

/* Full screen */
:-webkit-full-screen, :-webkit-full-screen * {
  -webkit-filter: none !important;
  filter: none !important;
}
:-moz-full-screen, :-moz-full-screen * {
  -webkit-filter: none !important;
  filter: none !important;
}
:fullscreen, :fullscreen * {
  -webkit-filter: none !important;
  filter: none !important;
}

/* Page background */
html {
  background: rgb(13,13,13) !important;
}

/* Custom rules */
.compatibility-with-darkreader-below-4-3-3 {
    background: white !important;
}

}</style>
    <script type="text/javascript" src="./Beautiful Racket_ Why Racket_ Why Lisp__files/clipboard.min.js"></script>
    <script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101120956);</script>
    <script async="" src="./Beautiful Racket_ Why Racket_ Why Lisp__files/js"></script>

  </head>
<body>
<div id="alert">Thank you for your comment</div>
<div id="doc"><h3 class="dept" anchorize="false"><a href="https://beautifulracket.com/">Beau­tiful Racket</a> / <a href="https://beautifulracket.com/#appendix">appendix</a></h3><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;why-racket-why-lisp&quot;)"></div><h1 anchor="why-racket-why-lisp" id="why-racket-why-lisp" hyphens="none">Why Racket? Why Lisp?</h1></div><div anchorize="false" style="height:1em"></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_y8YCw&quot;)"></div><p id="a_y8YCw"><em>Beau­tiful Racket</em> and <em>Prac­tical Typog­raphy</em> were made possible by a publishing system called <a class=" ext" href="http://pollenpub.com/">Pollen.</a> I created Pollen with the <a href="http://racket-lang.org/">Racket</a> program­ming language. Racket is a descen­dant of <a class=" ext" href="http://schemers.org/">Scheme,</a> which in turn is a descen­dant of Lisp.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_5IsIB&quot;)"></div><p id="a_5IsIB">So while Racket is not Lisp (in the specific Common Lisp sense), it is <em>a</em> Lisp (in the familial sense). Its core ideas—and core virtues—are shared with Lisp. So talking about Racket means talking about Lisp.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_HyW7x&quot;)"></div><p id="a_HyW7x">In prac­tical program­ming projects, Lisps are rare. Racket espe­cially so. Thus, before I orig­i­nally embarked on my Lisp adven­ture, I wanted to under­stand the costs &amp; bene­fits of using a Lisp. Why do Lisps have such a great repu­ta­tion, yet few users? Was I seeing some­thing everyone else missed? Or did they know some­thing I didn’t? To find out, I read what­ever I could find about Lisps, including Paul Graham’s <em><a class=" ext" href="http://www.paulgraham.com/hackpaint.html">Hackers &amp; Painters</a></em> and Peter Seibel’s <em><a class=" ext" href="http://www.gigamonkeys.com/book/">Prac­tical Common Lisp</a></em>. (OK, parts. It’s a big book.)</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_bJjwN&quot;)"></div><p id="a_bJjwN">What I found was plenty of Lisp flat­tery from expert Lisp program­mers. (Also plenty of Lisp kvetchery from its detrac­tors.) What I didn’t find were simple, persua­sive argu­ments in its favor. So here’s why Racket was the right tool for me, and what I see as the prac­tical virtues of Lisps in general.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;consider-the-source&quot;)"></div><h3 anchor="consider-the-source" class="subhead" id="consider-the-source"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#consider-the-source">Consider the source</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_xAWNr&quot;)"></div><p id="a_xAWNr">I didn’t study computer science in college (though I was a math major for two years, before switching to design). I’ve never held an offi­cial job as a programmer. Rather, program­ming has been a secondary skill I’ve used in my work as a web designer, type designer, and writer.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_T3NAB&quot;)"></div><p id="a_T3NAB">But in the last few years, I’ve spent an increasing amount of my time program­ming. This program­ming gener­ates income. So by the simplest defi­n­i­tion—does the skill make you money?—I suppose I qualify as a profes­sional programmer. And since most of my program­ming efforts are in Racket, I qualify as a profes­sional Racket programmer.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_RgaHw&quot;)"></div><p id="a_RgaHw">Mind you, I’m not claiming that I’m an <em>expert</em> programmer. Among the Racket commu­nity, which is laden with computer-science Ph­Ds &amp; profes­sors, I (have no choice but to) embrace my rela­tive inex­pe­ri­ence. Hence the title of my talk at Racket­Con 2014: <em><a class=" ext" href="https://www.youtube.com/watch?v=IMz09jYOgoc">Like a Blind Squirrel in a Ferrari</a></em>.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_muaS9&quot;)"></div><p id="a_muaS9">Yet despite my limi­ta­tions as a programmer, with Racket I’ve been able to render bigger ideas into programs more quickly, and with fewer bugs, than any language I’ve used before (and there have been many—BASIC, C, C++, Perl, Java, Java­Script, Python, and others). Since I haven’t gotten a brain trans­plant recently, there must be some­thing special about Racket as a language.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;if-youre-not-familiar-with-lisp&quot;)"></div><h3 anchor="if-youre-not-familiar-with-lisp" class="subhead" id="if-youre-not-familiar-with-lisp"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#if-youre-not-familiar-with-lisp">If you’re not familiar with Lisp</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_2yvjM&quot;)"></div><p id="a_2yvjM">Lisp is a language most program­mers have heard of, for two reasons. First, it’s one of the oldest computer languages, in use since 1958. Second, it’s accrued a repu­ta­tion as a language for brainiacs. Orig­i­nally this repu­ta­tion arose from its asso­ci­a­tion with the field of arti­fi­cial intel­li­gence. Since then, this repu­ta­tion has been main­tained by peri­odic endorse­ments from respected program­mers (latterly, <a class=" ext" href="http://www.catb.org/esr/faqs/hacker-howto.html">Eric Raymond</a> and <a class=" ext" href="http://www.paulgraham.com/avg.html">Paul Graham</a>) and the enduring fame of the text­book used in intro­duc­tory computer-science courses at MIT, <em><a class=" ext" href="http://mitpress.mit.edu/sicp/">Struc­ture and Inter­pre­ta­tion of Computer Programs</a></em> (which uses Scheme, and that one I did read start to finish).</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_NiXGx&quot;)"></div><p id="a_NiXGx">But as main­stream program­ming tools, Lisp and its descen­dants have been largely ignored. Popu­larity of program­ming languages is tricky to measure, but here’s a simple proxy—let’s count the number of projects currently hosted on <a class=" ext" href="http://github.com/">Git­Hub.</a> One could quibble about the accu­racy of this method, except that the results aren’t even close:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_u3bZx&quot;)"></div><div id="a_u3bZx" style="padding: 0% 10%"><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_lckJ3&quot;)"></div><div id="a_lckJ3"><table class="quick" form="false" id="a_pByU3"><tbody><tr><th>Language</th><th>Git­Hub projects</th></tr><tr><td hyphens="none">JavaScript</td><td hyphens="none">7,046,168</td></tr><tr><td hyphens="none">Java</td><td hyphens="none">6,119,333</td></tr><tr><td hyphens="none">Python</td><td hyphens="none">3,735,516</td></tr><tr><td hyphens="none">PHP</td><td hyphens="none">1,909,359</td></tr><tr><td hyphens="none">Ruby</td><td hyphens="none">1,664,718</td></tr><tr><td hyphens="none">Clojure</td><td hyphens="none">63,314</td></tr><tr><td hyphens="none">Lisp</td><td hyphens="none">17,723</td></tr><tr><td hyphens="none">Scheme</td><td hyphens="none">12,208</td></tr><tr><td hyphens="none">Racket</td><td hyphens="none">11,465</td></tr></tbody></table></div></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_yIEIe&quot;)"></div><p id="a_yIEIe"> The last four languages are Lisps, and together account for only 74,264 projects. Racket itself only accounts for a small frac­tion of this small frac­tion.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_S33CA&quot;)"></div><p id="a_S33CA">Popular program­ming languages aren’t neces­sarily good—look what’s at the top of that list. <span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner"><em>[Java­Script] has a lot of stupid in it … The good parts of [Java­Script] go back to Scheme and Self.</em><br>—Brendan Eich, <a class=" ext" href="http://www.jwz.org/blog/2010/10/every-day-i-learn-something-new-and-stupid/#comment-1020">here</a> and <a class=" ext" href="http://www.jwz.org/blog/2010/10/every-day-i-learn-something-new-and-stupid/#comment-1089">here</a></span></span> But unpop­ular languages often have fatal flaws that prevent wider adop­tion. As I was consid­ering languages, Racket had a lot to recom­mend it. But was there a fatal flaw I was over­looking? And by commit­ting to a Lisp, would I be painting myself into a corner? I wanted to under­stand the risks and bene­fits.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;flattery-gets-you-nowhere&quot;)"></div><h3 anchor="flattery-gets-you-nowhere" class="subhead" id="flattery-gets-you-nowhere"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#flattery-gets-you-nowhere">Flat­tery gets you nowhere</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_C5upJ&quot;)"></div><p id="a_C5upJ">I said above that Lisp flat­tery is easy to find. The problem with Lisp flat­tery is that it makes sense only to expe­ri­enced Lisp program­mers. To others—espe­cially those who are trying to decide whether to learn and use a Lisp—it just comes across as unsub­stan­ti­ated hoodoo.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_puqw7&quot;)"></div><p id="a_puqw7">For example, in his essay <em><a class=" ext" href="http://www.catb.org/esr/faqs/hacker-howto.html">How to Become a Hacker,</a></em> Eric Raymond says “Lisp is worth learning for … the profound enlight­en­ment expe­ri­ence you will have when you finally get it. That expe­ri­ence will make you a better programmer for the rest of your days, even if you never actu­ally use Lisp itself a lot.” Unfor­tu­nately Raymond doesn’t follow up this claim by describing the “enlight­en­ment expe­ri­ence,” nor why it’s “profound,” nor how it will improve your program­ming skills gener­ally.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_4jfHo&quot;)"></div><p id="a_4jfHo">To be fair, Raymond’s essay is not focused on Lisp. But compare <em><a class=" ext" href="http://www.paulgraham.com/avg.html">Beating the Aver­ages,</a></em> by Paul Graham, which is. Graham starts off by citing Raymond’s compli­ment to Lisp and seems ready to make the claim concrete.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_4czFe&quot;)"></div><p id="a_4czFe">Instead, he breaks it into smaller chunks of flat­tery. “We knew Lisp was a really good language for writing soft­ware quickly.” Because of what char­ac­ter­is­tics? He doesn’t say, but then describes Lisp as his “secret weapon.” OK, so what’s the secret? He says “program­ming languages vary in power.” Fine, but what exactly makes Lisp more powerful?</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_6jePR&quot;)"></div><p id="a_6jePR">Graham offers one concrete example: Lisp’s <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#macro"><span class="glossary-link-text">macro</span></a> facility, which he describes as its ability to make “programs that write programs.” After four years using a Lisp language, I’d agree with Graham that macros are great when you need them. But for someone new to Lisp languages, they’re not neces­sarily a bread-and-butter benefit.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_TdKBY&quot;)"></div><p id="a_TdKBY">I was hopeful when I opened Peter Seibel’s <em><a class=" ext" href="http://www.gigamonkeys.com/book">Prac­tical Common Lisp</a></em> and saw that the <a class=" ext" href="http://www.gigamonkeys.com/book/introduction-why-lisp.html">intro­duc­tion</a> was subti­tled “Why Lisp?” Yes, tell me! Seibel echoes Graham’s claim: “You’ll get more done, faster, using [Lisp] than you would using pretty much any other language.” OK, but how? Seibel wonders whether “I like Lisp because of some quirk in the way my brain is wired. It could even be genetic, since my dad has it too.” That’s not encour­aging to those of us outside your family. Ulti­mately, he sums up the appeal of Lisp by describing it as “the program­mable program­ming language.” But I’ve never&nbsp;used a program­mable program­ming language. Why should I start?</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_fhXXs&quot;)"></div><p id="a_fhXXs">And by the way, when do I get the speed and power you keep promising?</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_rjm58&quot;)"></div><p id="a_rjm58">In short—<strong>what’s in it for me, now?</strong></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_0gjYY&quot;)"></div><p id="a_0gjYY">This is the funda­mental ques­tion that Lisp advo­cates have to answer for new users. But more often, it’s side­stepped. I’m not picking on Raymond or Graham or Seibel. They’re excel­lent writers. As program­mers, they’re way out of my league. As I learn more about Lisps, I return to these arti­cles and they make more sense.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_NZLeJ&quot;)"></div><p id="a_NZLeJ">But these arti­cles are also emblem­atic of a general weak­ness of messaging about Lisp. I say that not as a ranking member of the Lisp commu­nity, but rather as someone who spent a lot of time seeking an answer to that funda­mental ques­tion. I never got it.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_uL2or&quot;)"></div><p id="a_uL2or">Seibel is passing the buck when he says that to under­stand the bene­fits of Lisp, “you’re going to have to learn some Lisp and see for your­self.” Sure, this method works—using Racket for a few months finally made the bene­fits of Lisp clear to me. But it also required an invest­ment of about 100–200 hours.&nbsp;<span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner"><span class="no-hyphens">For more on the perils of taxing reader patience, see <a class=" ext" href="http://practicaltypography.com/why-does-typography-matter.html">why does typog­raphy matter</a> in Prac­tical Typog­raphy.</span></span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_ZNhH0&quot;)"></div><p id="a_ZNhH0">That’s asking too much. If Lisp languages are so great, then it should be possible to summa­rize their bene­fits in concise, prac­tical terms. It should be possible to demon­strate the power of Lisp <a href="https://beautifulracket.com/stacker/">in one hour</a>, not 100. If Lisp advo­cates refuse to do this, then we shouldn’t be surprised when these languages remain stuck near the bottom of the charts.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;so-really-whats-in-it-for-me-now&quot;)"></div><h3 anchor="so-really-whats-in-it-for-me-now" class="subhead" id="so-really-whats-in-it-for-me-now"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#so-really-whats-in-it-for-me-now">So really—what’s in it for me, now?</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_2NmuE&quot;)"></div><p id="a_2NmuE">In a word, <em>expres­sive­ness:</em> the measure of how easy it is to put your ideas into code. For instance, an expres­sive language like Racket lets you write the “Hello world” program like this:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_LKlcy&quot;)"></div><div class="highlight-container" id="a_LKlcy"><div id="code_43" form="false" decode="exclude" style="font-size:0;width:0;height:0">"Hello world"</div><div class="highlight" form="false" id="a_WN4dd"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre>"Hello world"
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk" data-clipboard-target="#code_43" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_IOOlh&quot;)"></div><p id="a_IOOlh">Whereas a less expres­sive language—I won’t name names—requires this:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_n5gO8&quot;)"></div><div class="highlight-container" id="a_n5gO8"><div id="code_44" form="false" decode="exclude" style="font-size:0;width:0;height:0">public class HelloWorld {<br>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Hello world");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><div class="highlight" form="false" id="a_SA9bL"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="source"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk1" data-clipboard-target="#code_44" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_g2r6x&quot;)"></div><p id="a_g2r6x">Conci­sion is valu­able, but expres­sive­ness also embodies other qual­i­ties: preci­sion, read­ability, flex­i­bility, poten­tial for gener­al­iza­tion.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Vldpk2&quot;)"></div><p id="a_Vldpk2"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/racetrack.jpg"></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_YBsQY&quot;)"></div><p id="a_YBsQY">Compared to other languages, Lisps are tremen­dously expres­sive. Like the over­pow­ered Japanese motor­cycle I once owned, they go where you want, very quickly, with a minimum of input. If you’ve ridden a motor­cycle, then you know what I mean. If you haven’t, good news—Lisps are cheaper and safer.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_9HUGi&quot;)"></div><p id="a_9HUGi">Here’s my ranking of the language features that offered the most imme­diate value to me, when I was a programmer new to the Lisp world. For each, I’ve noted whether it’s a feature of Racket specif­i­cally, or Lisps gener­ally.</p></div><ol><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_CU5IP&quot;)"></div><p id="a_CU5IP"><strong>Every­thing is an expres­sion.</strong> [Lisps] Most program­ming languages are a combi­na­tion of two distinct ingre­di­ents: <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#expression"><span class="glossary-link-text">expres­sions</span></a></em> (things that are eval­u­ated to produce a value) and <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#statement"><span class="glossary-link-text">state­ments</span></a></em> (things that denote an action). For instance, in Python, <span class="my-code" decode="exclude">x = 42</span> is a state­ment, and <span class="my-code" decode="exclude">x + 42</span> is an expres­sion.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_CXX6H&quot;)"></div><p id="a_CXX6H">State­ments and expres­sions are distinct because while expres­sions can be natu­rally nested with each other, state­ments and expres­sions cannot. For instance, in Python, this is a valid expres­sion:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_TGk6g&quot;)"></div><div class="highlight-container" id="a_TGk6g"><div id="code_45" form="false" decode="exclude" style="font-size:0;width:0;height:0">42 + 101</div><div class="highlight" form="false" id="a_3qRd5"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="mi">42</span> <span class="o">+</span> <span class="mi">101</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk3" data-clipboard-target="#code_45" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_wfzwn&quot;)"></div><p id="a_wfzwn">And so is this, substi­tuting another expres­sion for the right-hand value:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_e1s0B&quot;)"></div><div class="highlight-container" id="a_e1s0B"><div id="code_46" form="false" decode="exclude" style="font-size:0;width:0;height:0">42 + (100 + 100)</div><div class="highlight" form="false" id="a_fqmRb"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="mi">42</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk4" data-clipboard-target="#code_46" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_5ND4C&quot;)"></div><p id="a_5ND4C">But this is not valid:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_5CJlS&quot;)"></div><div class="highlight-container" id="a_5CJlS"><div id="code_47" form="false" decode="exclude" style="font-size:0;width:0;height:0">42 + if 1 &lt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200</div><div class="highlight" form="false" id="a_G1Z94"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="source"><pre><span class="mi">42</span> <span class="o">+</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
         <span class="mi">100</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="mi">200</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk5" data-clipboard-target="#code_47" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_CJSPp&quot;)"></div><p id="a_CJSPp">Why? Because in Python, a stan­dard <span class="my-code" decode="exclude">if</span> condi­tional is a state­ment, and can only be used in certain posi­tions.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_7dNqY&quot;)"></div><p id="a_7dNqY">By making every­thing an expres­sion, however, Lisps remove this limi­ta­tion. Since expres­sions are nestable, anything in the language can be combined with nearly anything else. For instance, because an <a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" class="docs" hyphens="none">if</a> condi­tional is an expres­sion, you can use it in place of a value:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_hvIW1&quot;)"></div><div class="highlight-container" id="a_hvIW1"><div id="code_48" form="false" decode="exclude" style="font-size:0;width:0;height:0">(+ 42 (if (&lt; 1 0) 100 200))</div><div class="highlight" form="false" id="a_gYDaO"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" class="docs" hyphens="none">+</a></span> <span class="mi">42</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" class="docs" hyphens="none">if</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))" class="docs" hyphens="none">&lt;</a></span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">100</span> <span class="mi">200</span><span class="p">))</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk6" data-clipboard-target="#code_48" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_y9Rah&quot;)"></div><p id="a_y9Rah">“But wait! Python has a ternary condi­tional expres­sion!” It doesn’t change the essen­tial point, but OK—you can indeed write this:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_B7HgX&quot;)"></div><div class="highlight-container" id="a_B7HgX"><div id="code_49" form="false" decode="exclude" style="font-size:0;width:0;height:0">42 + (100 if 1 &lt; 0 else 200)</div><div class="highlight" form="false" id="a_ia09R"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="mi">42</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk7" data-clipboard-target="#code_49" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_hfZCA&quot;)"></div><p id="a_hfZCA">But now suppose we want to use a condi­tional in place of the oper­ator, not the right-hand value. In a Lisp, because every­thing is an expres­sion—including the oper­ator itself—this is easy:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_vcxCY&quot;)"></div><div class="highlight-container" id="a_vcxCY"><div id="code_50" form="false" decode="exclude" style="font-size:0;width:0;height:0">((if (&lt; 1 0) + *) 42 100)</div><div class="highlight" form="false" id="a_AQJKm"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="p">((</span><span class="nb"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" class="docs" hyphens="none">if</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))" class="docs" hyphens="none">&lt;</a></span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" class="docs" hyphens="none">+</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" class="docs" hyphens="none">*</a></span><span class="p">)</span> <span class="mi">42</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk8" data-clipboard-target="#code_50" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_iNzei&quot;)"></div><p id="a_iNzei">But if you try the same thing in Python, it will raise a syntax error:</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Qx0Te&quot;)"></div><div class="highlight-container" id="a_Qx0Te"><div id="code_51" form="false" decode="exclude" style="font-size:0;width:0;height:0">42 (+ if 1 &lt; 0 else *) 100</div><div class="highlight" form="false" id="a_GEquL"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span class="mi">42</span> <span class="p">(</span><span class="o">+</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">*</span><span class="p">)</span> <span class="mi">100</span>
</pre></div>
</td></tr></tbody></table></div><div class="copy-button" form="false" onclick="notify(&#39;copied to clipboard&#39;, 1000)" id="a_Vldpk9" data-clipboard-target="#code_51" data-clipboard-action="copy"><img src="./Beautiful Racket_ Why Racket_ Why Lisp__files/download.svg" alt="copy to clipboard"></div></div></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_8QeAf&quot;)"></div><p id="a_8QeAf">Why? Because Python oper­a­tors are not expres­sions.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_UD59J&quot;)"></div><p id="a_UD59J">This is a synthetic example. The point is not that you’d neces­sarily want to do this, but that Lisps permit it. You don’t run into the syntactic guardrails that are lurking in other languages. As a programmer, this simpli­fies your work, because every­thing snaps together easily. It also expands your possi­bil­i­ties, because you can combine parts of the language in unusual ways if you feel like it.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_8u6NZ&quot;)"></div><p id="a_8u6NZ">It’s similar to the basic idea behind Legos. Other building sets offer special­ized pieces that can only fit together certain ways. But by sharing uniform measure­ments, Lego bricks offer maximum possi­bil­i­ties for combi­na­tions. This ends up being more flex­ible &amp; more fun.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_92337&quot;)"></div><p id="a_92337">So it is with an expres­sion-based language. If you find this idea exciting, congrat­u­la­tions—you might be a Lisp programmer. (If you find this idea weird and scary, this is a good moment to <a class=" ext" href="https://www.youtube.com/watch?v=8CmeDu7K7f4">bail out.</a>)</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_7fc19&quot;)"></div><p id="a_7fc19"><strong>Every expres­sion is either a single value or a list.</strong> [Lisps] Single values are things like numbers and <a href="https://beautifulracket.com/explainer/stringlike-types.html">strings</a> and <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#hash-table"><span class="glossary-link-text">hash tables</span></a>. (In Lisps, they’re some­times called <em>atoms</em>.) That part is no big deal.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_VPEC8&quot;)"></div><p id="a_VPEC8">The list part, however, is a big deal. In a language like Python, the list is one data type within the language. But in Lisps, the <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#list"><span class="glossary-link-text">list</span></a> is more like an orga­nizing prin­ciple for every­thing that happens. <span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner">The name “Lisp” is an abbre­vi­a­tion for “list processing.”</span></span> So yes, you can use the list as a data type. But a func­tion call is also a list. In fact, the source code for the func­tion is a list. Actu­ally, the rest of the program is too. Lists are every­where.&nbsp;<span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner">The fancy CS term for this prop­erty is <em>homoiconicity</em>.</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_IOotS&quot;)"></div><p id="a_IOotS">The bene­fits of lists are similar to that of expres­sions. By bringing more of the language into a consis­tent form, more possi­bil­i­ties arise for how pieces can be combined and manip­u­lated.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_b3bdV&quot;)"></div><p id="a_b3bdV">Seibel describes Lisp as a tool for getting “more done, faster.” Here, you can start to see why this is so. Lisp languages are immensely flex­ible and permis­sive in how their pieces can be connected. This means that the way you <em>think</em> about a program­ming problem can be quite close to the way you actu­ally program it. (This is also why Lisps have tradi­tion­ally excelled for proto­types and exploratory work.)</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_oxN9a&quot;)"></div><p id="a_oxN9a">To be fair, getting the most out of a Lisp means learning to think more in the Lisp idiom of lists and expres­sions. For that reason, I agree with Seibel—trying it your­self is the best way to be convinced of the bene­fits. As you get a feel for lists and expres­sions, it does pay increasing divi­dends throughout the language. You see how tiny lines of code can produce epic amounts of work. You also start to appre­ciate that even in a well-designed language like Python, you’re spending a lot of time shaping your ideas to fit its limi­ta­tions, like shaving an invis­ible yak.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_JDNGR&quot;)"></div><p id="a_JDNGR"><strong>Func­tional program­ming.</strong> [Lisps] Yes, I know that other languages offer func­tional-program­ming features, and that Lisps aren’t consid­ered pure func­tional languages. But many program­mers haven’t been exposed to this idiom, and thus tend to under­rate its bene­fits. I know I was in that cate­gory.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Om4Rm&quot;)"></div><p id="a_Om4Rm"><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#functional-programming"><span class="glossary-link-text">Func­tional program­ming</span></a> doesn’t mean program­ming with <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#function"><span class="glossary-link-text">func­tions</span></a>. Every­body does that. Func­tional program­ming refers to a stricter style where func­tions receive certain data as input, process only that data, and return a result. In func­tional program­ming, func­tions avoid two habits common in other languages: <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#mutation"><span class="glossary-link-text">muta­tion</span></a></em> (= changing data in-place rather than returning a value) and relying on <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#state"><span class="glossary-link-text">state</span></a></em> (= extra context that’s not provided as input, for instance global vari­ables).</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_G2MXB&quot;)"></div><p id="a_G2MXB">“Wait—I love state and muta­tion. Why would you take them away?” Because they’re false friends. They contra­dict the essen­tial concept of a func­tion, which is to encap­su­late data and algo­rithms. When a func­tion relies on state or muta­tion, it’s oper­ating outside those bound­aries. There­fore, you either take on an increasing house­keeping burden to keep track of how func­tions affect each other, or watch your program sink into a swamp of myste­rious, compli­cated bugs.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_K71iY&quot;)"></div><p id="a_K71iY">Program­ming in a func­tional style takes more effort at the outset. But it encour­ages you to struc­ture the program in a clean, compart­men­tal­ized way. This pays off imme­di­ately in programs that are easier to test and debug. It’s also more likely to lead to reusable compo­nents, since func­tions are truly inde­pen­dent.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_M3mzh&quot;)"></div><p id="a_M3mzh">This bite-the-bullet aspect of func­tional program­ming is another reason why you can get “more done, faster” with a Lisp. The differ­ence between proto­type and produc­tion code often ends up being small, because you don’t take as many short­cuts at the start. The program grows and evolves more smoothly because it’s easy to change one part without causing ripple effects else­where.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_vmsLq&quot;)"></div><p id="a_vmsLq"><strong>Macros.</strong> [Racket] Some Rack­e­teers quibble with this term, prefer­ring <em>syntax trans­formers</em>, because a Racket <a href="http://docs.racket-lang.org/guide/macros.html">macro</a> can be more sophis­ti­cated than the usual Common Lisp macro.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_KGBbb&quot;)"></div><p id="a_KGBbb">A macro in Common Lisp is a func­tion that runs at <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#compile-time"><span class="glossary-link-text">compile time</span></a>, accepting symbols as input and injecting them into a template to produce new code.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_bAV9J&quot;)"></div><p id="a_bAV9J">Macros in Racket, on the other hand, rely on the concept of <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#hygiene"><span class="glossary-link-text">hygiene</span></a>. They can handle Common Lisp-style macros, but also more elab­o­rate syntax rearrange­ments.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_H9jTy&quot;)"></div><p id="a_H9jTy">But forget that—what’s in it for you? As a programmer, you end up getting two bites at the apple every time you run a file: Racket runs the macros (which alter the source code), and then the source code itself.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_v0SLB&quot;)"></div><p id="a_v0SLB">Unlike some­thing like the C preprocessor, which is basi­cally a sepa­rate mini-language, Racket macros are them­selves Racket func­tions that give you access to every­thing in Racket. Like lists and expres­sions, macros add another layer of expres­sive possi­bil­i­ties.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_pwJR1&quot;)"></div><p id="a_pwJR1"><strong>Create new program­ming languages.</strong> [Racket] When I first read that Racket could be used to <a href="http://docs.racket-lang.org/guide/languages.html">create new languages,</a> I had two thoughts—<em>are they serious?</em> and <em>would I really want to do that?</em> The answers were <em>yes</em> and <em>oh&nbsp;hell&nbsp;yes.</em></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_OVWAw&quot;)"></div><p id="a_OVWAw">Between expres­sions, lists, and macros, Racket gives you a huge amount of semantic flex­i­bility. But on top of that, it also adds syntactic flex­i­bility, in that you can define a <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#reader"><span class="glossary-link-text">reader</span></a></em> that converts surface syntax into stan­dard Racket <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#s-expression"><span class="glossary-link-text">S-expres­sions</span></a>, and&nbsp;an <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#expander"><span class="glossary-link-text">expander</span></a></em> that deter­mines the meaning of these S-expres­sions. <span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner">Paul Graham’s program­ming language <a class=" ext" href="http://arclanguage.org/">Arc,</a> a dialect of Lisp, was built on top of Racket.</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_vQdh7&quot;)"></div><p id="a_vQdh7">You can use this facility to make <a href="http://docs.racket-lang.org/ts-guide/index.html">special­ized dialects</a> of Racket. Or imple­ment <a href="http://docs.racket-lang.org/r6rs/index.html">earlier languages.</a> Or create entirely <a href="http://docs.racket-lang.org/datalog/datalog.html">new languages</a> with their own rules. You can use any of these languages within Dr­Racket to code new projects. (These special languages are some­times called <em><a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#domain-specific-language"><span class="glossary-link-text">domain-specific languages</span></a></em>, or <em>DSLs</em>.) Scribble is a DSL based on Racket; Pollen is a set of DSLs based on Scribble.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_1p7B2&quot;)"></div><p id="a_1p7B2">If you’re like most program­mers, you’ve never had a tool for making a new language, so you’ve not consid­ered it a real­istic approach to a problem. And you won’t need it all the time. But when you do, it is awesome, in both the new and old senses of that word.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_d0ARq&quot;)"></div><p id="a_d0ARq">(The sequel to this piece—<a href="https://beautifulracket.com/appendix/why-lop-why-racket.html"><em>Why language-oriented program­ming? Why Racket?</em></a>—is devoted to this topic.)</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_3dPRL&quot;)"></div><p id="a_3dPRL"><strong>Libraries &amp; docu­men­ta­tion.</strong> [Racket] This might not look like a compet­i­tive differ­en­tiator—doesn’t every program­ming language have libraries &amp; docu­men­ta­tion?</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_N2KtA&quot;)"></div><p id="a_N2KtA">Yes, but prob­ably not like this. As a conse­quence of being used in research settings for many years—Racket’s core devel­op­ment team is made of computer-science profes­sors—Racket’s libraries &amp; docs are more like a trans­mis­sion from a highly evolved alien intel­li­gence.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_LSaoM&quot;)"></div><p id="a_LSaoM">You get the essen­tials, of course:&nbsp;<a href="http://docs.racket-lang.org/web-server-internal/index.html">web server,</a> <a href="http://docs.racket-lang.org/json/index.html">JSON,</a> <a href="http://docs.racket-lang.org/xml/index.html">XML,</a> <a href="http://docs.racket-lang.org/draw/index.html">drawing,</a> <a href="http://docs.racket-lang.org/foreign/index.html">foreign-func­tion inter­face,</a> and so on. Then you notice pack­ages you maybe didn’t expect:&nbsp;<a href="http://docs.racket-lang.org/framework/index.html">GUI appli­ca­tion frame­work,</a> <a href="http://docs.racket-lang.org/plot/index.html">math plot­ting,</a> <a href="http://docs.racket-lang.org/pkg/index.html">package-distri­bu­tion system,</a> <a href="http://docs.racket-lang.org/rackunit/index.html">unit tester.</a> Beyond that, your face starts to melt a little bit: <a href="http://docs.racket-lang.org/redex/index.html">seman­tics engi­neering?</a> <a href="http://docs.racket-lang.org/future-visualizer/index.html">Futures visu­al­izer?</a></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_ThF9h&quot;)"></div><p id="a_ThF9h">I won’t pretend to know what all this shit does. A lot of it is over my head. But I like that. Each week I use Racket, I end up exploring a new part of the library, and learning some­thing new. As opposed to other languages that seem to kill brain cells on contact (= pretty much anything named *Script, I find).&nbsp;</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Fi5nc&quot;)"></div><p id="a_Fi5nc">This learning is only possible because of Racket’s truly outstanding docu­men­ta­tion. It’s vast, thor­ough, precise, and approach­able. <a href="http://docs.racket-lang.org/">See for your­self.</a> <span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner">If you don’t like the typog­raphy and layout of the docs, blame me.</span></span></p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_QpSbi&quot;)"></div><p id="a_QpSbi"><strong>Dr­Racket.</strong> [Racket] Yes, I know how to use a command line. But Racket includes a cross-plat­form graph­ical IDE called <a href="http://docs.racket-lang.org/drracket/index.html">Dr­Racket</a> that’s pretty great. Dr­Racket lets you edit, run, and debug Racket source files (or any other language based on Racket—see item #9 on this list.)</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_qS0A6&quot;)"></div><p id="a_qS0A6">No, it doesn’t have the Ginsu-level search-and-replace facil­i­ties of some­thing like Sublime Text. But it does have helpful editing features opti­mized for Racket code (for instance, you can right-click on a symbol name and rename it throughout the file, or jump from a func­tion to its docu­men­ta­tion).</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_K2ZIt&quot;)"></div><p id="a_K2ZIt">More­over, the command line within Dr­Racket doesn’t just show plain text—it can show stacked frac­tions, <a href="http://docs.racket-lang.org/teachpack/2htdpimage.html">draw­ings,</a> <a href="http://docs.racket-lang.org/plot/renderer3d.html?q=plot">math plots,</a> and other unex­pected guests. If your command line does all that, by all means keep using it.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_dV4tA&quot;)"></div><p id="a_dV4tA"><strong>X-expres­sions.</strong> [Racket] This choice is some­what biased by my work with Racket, which mostly involves docu­ment processing and type­set­ting. But related topics arise in most web program­ming. An X-expres­sion is a special native data struc­ture that Lisps use to repre­sent HTML and other XML-ish data.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_I95I0&quot;)"></div><p id="a_I95I0">Well, not “special” in a Lispy sense—keeping with the usual policy, an X-expres­sion is just another list—but special in the sense that other program­ming languages don’t have it. Usually your choice is to repre­sent HTML either as a string or as a full XML tree. A string is wrong because it doesn’t capture the struc­ture of the HTML, as defined by its tags and attrib­utes. An XML tree shows this struc­ture, but conceals the sequen­tial nature of the data elements, and is unwieldy to work with.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_kEs6W&quot;)"></div><p id="a_kEs6W">An X-expres­sion ends up being an ideal hybrid between a string and a tree. More­over, because it’s just another list-based expres­sion in the language, you have a lot of options for processing it. Trans­lating an X-expres­sion to or from a text repre­sen­ta­tion using angle brackets is trivial and fast. (<a href="http://pkg-build.racket-lang.org/doc/pollen/second-tutorial.html#%28part._.X-expressions%29">Details.</a>)</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_OyaFm&quot;)"></div><p id="a_OyaFm">Given the close kinship between XML-ish data struc­tures and Lisp languages, I have no expla­na­tion why, during the Internet era, they’ve not been paired more often. They’re like peanut butter and jelly.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_TtSCx&quot;)"></div><p id="a_TtSCx"><strong>Scribble.</strong> [Racket] Pollen wouldn’t have been possible without <a href="http://docs.racket-lang.org/scribble/index.html">Scribble,</a> so for me, this has been the stone-cold killer feature of Racket. But that won’t be true for everyone, so I’m moving it down the list.&nbsp;<span class="tooltip" onclick="this.classList.toggle(&#39;tooltip_visible&#39;)">&nbsp;+&nbsp;<span class="tooltip-inner">Scribble was orig­i­nally created to serve as Racket’s <a class=" ext" href="https://www.cs.utah.edu/plt/publications/icfp09-fbf.pdf">docu­men­ta­tion language</a> (a job it does well).</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_L1DOZ&quot;)"></div><p id="a_L1DOZ">Scribble is a dialect of Racket that inverts the ordi­nary rela­tion­ship of plain text and code: rather than embed­ding text strings within source, a Scribble docu­ment consists of code expres­sions embedded within plain text.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_QZ2GK&quot;)"></div><p id="a_QZ2GK">“So it’s like an HTML template language.” Yes, in the sense that a template language allows code to be embedded in text. But also no, because a template language is usually a pidgin version of a real program­ming language. Scribble, by contrast, lets you invoke any Racket code simply by adding a command char­acter to the front. In keeping with the theme already estab­lished, this approach is both simpler (because there’s almost nothing new to learn) and more powerful (because you can invoke anything in Racket).</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Jd4s5&quot;)"></div><p id="a_Jd4s5">In its combi­na­tion of text and code, Scribble has more kinship with La­TeX. While it doesn’t have the type­set­ting facil­i­ties of La­TeX, the program­ming facil­i­ties are much better.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_fFuGh&quot;)"></div><p id="a_fFuGh"><strong>Oppor­tu­ni­ties to partic­i­pate.</strong> [Racket] In theory, open-source soft­ware projects create the oppor­tu­nity for groups of devel­opers to join together and make better things in collab­o­ra­tion than they could sepa­rately.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_vxCU0&quot;)"></div><p id="a_vxCU0">In prac­tice, I’ve found that they sort into a bimodal distri­bu­tion: over here, the under­doc­u­mented solo projects that sputter along fitfully (if at all); over there, the mature, popular projects that can be intim­i­dating for new contrib­u­tors.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_JM40j&quot;)"></div><p id="a_JM40j">As an open-source project, <a class=" ext" href="https://github.com/racket/racket">Racket</a> is posi­tioned at a happy medium. The core devel­op­ment team has been working together for years, and the commits remain <a class=" ext" href="https://github.com/racket/racket/commits/master">fast &amp; furious.</a> But they’re friendly scien­tists, not Shire-dwelling egotists, and remain recep­tive to improve­ments across the whole system. If you have a better idea, they’ll listen; if you code it up to their stan­dards and make a pull request, they’ll take it.</p></div></li></ol><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_nYNRb&quot;)"></div><p id="a_nYNRb">The point of this list has been to tell you about the posi­tives. That doesn’t mean there aren’t nega­tives. The small pool of Racket program­mers means that when you hit a pothole, it’s possible no one’s ever seen your problem (= the inverse of <a class=" ext" href="http://en.wikipedia.org/wiki/Linus&#39;s_Law">Linus’s Law</a>). If I wanted to hire a Racket programmer, the options would be few.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_LamO2&quot;)"></div><p id="a_LamO2">Still, why shouldn’t I be enthu­si­astic? What I’ve been able to accom­plish so far with Racket has been tremen­dously useful, educa­tional, and fun—the most fun I’ve had in 25+ years of program­ming.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_53fQB&quot;)"></div><p id="a_53fQB">If you think I sound like a fanboy or cult member, I can live with that. But those are people whose enthu­siasm is dispro­por­tionate to reality. Here, I’ve tried to stay out of the clouds (and the weeds) and explain the concrete, prac­tical features that have made Racket such a plea­sure in my own work.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_m39TE&quot;)"></div><p id="a_m39TE">As always, your mileage may vary. But if I persuade a few people to <a href="http://racket-lang.org/download/">down­load Racket</a> and try it, I’ll be happy. In fact, if you try it and <em>don’t</em> like it, I invite you to <a href="https://beautifulracket.com/about-the-author.html">contact</a> me, because I’m always curious to hear dissenting opin­ions.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Nn64r&quot;)"></div><p id="a_Nn64r">I will end by taking on the big kahuna—</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;does-profound-enlightenment-await&quot;)"></div><h3 anchor="does-profound-enlightenment-await" class="subhead" id="does-profound-enlightenment-await"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#does-profound-enlightenment-await">Does “profound enlight­en­ment” await?</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_CLSPf&quot;)"></div><p id="a_CLSPf">I won’t claim I’ve reached the top of the moun­tain. But I can tell you what the view looks like so far.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_ZQ3Mm&quot;)"></div><p id="a_ZQ3Mm">There’s a sense in which Lisp and its descen­dants are more than program­ming languages. They’re tools in the broader intel­lec­tual inquiry into the theory of compu­ta­tion. Lisp’s inventor, John Mc­Carthy, orig­i­nally <a class=" ext" href="http://www-formal.stanford.edu/jmc/history/lisp.ps">consid­ered Lisp</a> a “way of describing computable func­tions much neater than the Turing machines,” adapting the nota­tion of <a class="glossary" href="https://beautifulracket.com/appendix/glossary.html#lambda-calculus"><span class="glossary-link-text">lambda calculus</span></a> to do so. Racket, like­wise, has grown out of scien­tific research and explo­ration.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_7I0JH&quot;)"></div><p id="a_7I0JH">The theory of compu­ta­tion is just one of many great scien­tific discov­eries in the last 100 years. But I don’t get to use quantum mechanics or rela­tivity or DNA sequencing in my daily work. When I’m program­ming, however, I’m using compu­ta­tion.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_9eH95&quot;)"></div><p id="a_9eH95">Racket, as a Lisp dialect, has many prac­tical bene­fits. But it also opens a window onto a vast theo­ret­ical world that under­lies every­thing we can do with programs. I’m not a brainiac computer scien­tist. But some days, through that window, I can start to see a bit of what they see—some math, some science, a lot of truth, and more than a little beauty&nbsp;and mystery.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_V2Odm&quot;)"></div><p id="a_V2Odm">Paul Graham <a class=" ext" href="http://www.paulgraham.com/avg.html">calls Lisp</a> a “secret weapon.” I would clarify: Lisp itself isn’t the secret weapon. Rather, <strong>you</strong> are—because a Lisp language offers you the chance to discover your poten­tial as a programmer and a thinker, and thereby raise your expec­ta­tions for what you can accom­plish.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_ZJRtj&quot;)"></div><p id="a_ZJRtj">If that’s not a step toward enlight­en­ment, I don’t know what is.</p></div><div anchorize="false" style="height:1em"></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;further-reading&quot;)"></div><h3 anchor="further-reading" class="subhead" id="further-reading"><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html#further-reading">Further reading</a></h3></div><ul><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_xfMXt&quot;)"></div><p id="a_xfMXt">Racket’s killer app is language-oriented program­ming, which I discuss in the sequel to this piece—<a href="https://beautifulracket.com/appendix/why-lop-why-racket.html"><em>Why language-oriented program­ming? Why Racket?</em></a></p></div></li></ul></div>

<a class="nav-left" href="https://beautifulracket.com/appendix/why-lop-why-racket.html">← prev</a>








<!-- © 2016–19 Matthew Butterick -->
</body></html>