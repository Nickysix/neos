# ÿßŸÑÿ≥ŸëŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ ‚îÄ‚ÄúHello, and welcome‚Äù in Arabic (ÿßŸÑÿπÿ±ÿ®ŸäŸëÿ©)
#+TITLE: A Life Configuring Emacs
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+DATE: 2018-07-25
#+DESCRIPTION: My Emacs Initialisation File, Written in Org-mode.
#+STARTUP: indent lognoteclock-out
#+OPTIONS: html-postamble:nil toc:nil d:nil
#+PROPERTY: header-args :tangle init.el :comments link :results none

# ‚îÄAlBasmala keywords‚îÄ
# DRAFT: yes
#+SOURCEFILE: https://github.com/alhassy/emacs.d/blob/master/init.org
#+IMAGE: ../assets/img/emacs_logo.png
#+CATEGORIES: Emacs Lisp
:TASKS:

# TODO: MA: ‚á® Add unit tests for the init file.

# ox-pandoc is "another exporter that translates Org-mode file to various other formats via Pandoc".
# (shell-command "brew install pandoc")
# (use-package ox-pandoc)

;; Omit empty lines between headings in the collapsed view
(setq org-cycle-separator-lines 0)

(package-install 'fold-this)        ;; Folding away regions of text

#+BEGIN_SRC emacs-lisp :results replace :tangle yes
show-me

(defun show-me ()
  "Evaluate a Lisp expression and insert its value
   as a comment at the end of the line.

   Useful for documenting values or checking values.
  "
  (interactive)
  (-let [it
         (thread-last (thing-at-point 'line)
           read-from-string
           car
           eval
           (format " ;; ‚áí %s"))]
    (end-of-line)
    (insert it)))
#+END_SRC
:End:

* TODO COMMENT Clean up
:PROPERTIES:
:CUSTOM_ID: COMMENT-Clean-up
:END:
# (org-babel-load-file "init.org")

# Text and Prog modes are the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Major-Modes.html][basic major modes]] that other modes inheirt from,
# and so we can hook onto these two modes if we want something to work almost everywhere.

:TODO:
#+BEGIN_SRC emacs-lisp
;; (setq org-modules (quote (org-info org-tempo org-protocol org-habit org-mac-link)))
#+END_SRC

#+RESULTS:

:End:

# Includes fonts for subscripts; e.g., ‚Çê‚Çô‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö‚Çú‚Çõ
brew cask install font-symbola
:unicode:
Unicode doesn't intend to cover things
that can be achieved with markup, so
only a limited subset of the alphabet
is available as subscript; but all is
available as superscript, except ‚Äòq‚Äô.
‚Çê‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö·µ£‚Çõ‚Çú·µ§·µ•‚Çì
‚Å∞ ¬π ¬≤ ¬≥ ‚Å¥ ‚Åµ ‚Å∂ ‚Å∑ ‚Å∏ ‚Åπ ‚Å∫ ‚Åª ‚Åº ‚ÅΩ ‚Åæ ‚ÇÄ ‚ÇÅ ‚ÇÇ ‚ÇÉ ‚ÇÑ ‚ÇÖ ‚ÇÜ ‚Çá ‚Çà ‚Çâ ‚Çä ‚Çã ‚Çå ‚Çç ‚Çé
·µÉ ·µá ·∂ú ·µà ·µâ ·∂† ·µç  ∞ ‚Å±  ≤ ·µè À° ·µê ‚Åø ·µí ·µñ  ≥ À¢ ·µó ·µò ·µõ  ∑ À£  ∏ ·∂ª
·¥¨ ·¥Æ ·¥∞ ·¥± ·¥≥ ·¥¥ ·¥µ ·¥∂ ·¥∑ ·¥∏ ·¥π ·¥∫ ·¥º ·¥æ ·¥ø ·µÄ ·µÅ ‚±Ω ·µÇ
·µÖ ·µù ·µû ·µü ·µã ·∂ø ·∂• ·∂≤ ·µ† ·µ° ·µ¶ ·µß ·µ® ·µ© ·µ™
:End:

;; In fill mode, when you type past the end of a line,
;; Emacs automatically starts a new line, cleverly formatting paragraphs.
;; This is a powerful form of ‚Äúword wrap‚Äù.
;;
(add-to-hook org-mode-hook 'turn-on-auto-fill)

+ Emacs CheatSheet
  - M-n ùïè / C-u n ùïè :: Repeat command ùïè $n$ times.
       - /n/ may be omitted in the second form, defaulting to 4.
       - Whence, it may be stacked: ‚ÄúC-u ‚ãØ C-u ùïè‚Äù repeats command ùïè
         4‚Åø-times where n is the number of C-u commands.

       - Holding ~Alt~ key and press ~1~ then ~2~ then ~3~ then release the
         ~Alt~ key, and, say, press the ~j~ key. Now you have 123 j's
         inserted lol.

   - loop from cl-macs.el has support for destructing like CL:

      (loop for (key . value) in my-list
            collect (cons value key))

** COMMENT Referencing Text From Code Blocks ---Attaching prose as doc strings :noexport:ignore:
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Referencing-Text-From-Code-Blocks----Attaching-prose-as-doc-strings
  :END:
  :PROPERTIES:

  :END:

Sources:
+ John Kitchin https://lists.gnu.org/archive/html/emacs-orgmode/2018-05/msg00350.html
+ https://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html

# NAME: get-named-text
#+NAME: commentary
#+BEGIN_SRC emacs-lisp :var name="" :results replace
(let ((el (org-element-map (org-element-parse-buffer) org-element-all-elements
        (lambda (el)
          (when (string= (org-element-property :name el) name)
        el))
        nil t)))
  (let ((s (buffer-substring (org-element-property :contents-begin el)
                 (org-element-property :contents-end el))))
    (replace-regexp-in-string "\\\"" "\\\\\"" s)))
#+END_SRC

*** COMMENT Example
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Example
   :END:
   :PROPERTIES:

   :END:
For example:
#+NAME: ADD
#+BEGIN_SRC emacs-lisp -n -r :noweb yes :tangle test.el
(defun add (x y)
  "One line description of adding X and Y.
  <<get-named-text("DOC-OF-ADD")>> ;; code to code
  <<get-named-text("add-options")>>"
  (+ x y)
  )
#+END_SRC

#+NAME: DOC-OF-ADD
We use the function add to calculate the sum of two numbers.

#+NAME: add-options
- one
- two
- three
- and of course "optional things"

**** There is a reason we only support two args
    :PROPERTIES:
    :CUSTOM_ID: There-is-a-reason-we-only-support-two-args
    :END:
    :PROPERTIES:
    :ID:       BAD97113-3561-4A4A-BA07-0CD5BF6BA35F

    :END:

** itify
   :PROPERTIES:
   :CUSTOM_ID: itify
   :END:
   :PROPERTIES:

   :END:

+ ~itify~ :: A macro that generates macros!

  A common pattern I've observed is code of the form
  ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
  function ~f~ that is invoked with two arguments; the first being a
  function. The declaration ~(itify f~) will produce a macro named ~f-it~
  that takes two arguments where the first is an expression involving
  a free variable ~it~ such that
         | /(f-it expr-with-it more)  ‚âà  (f (Œª (it) expr-with-it) more)/  |

  We then test this out on the utility ~rename-mixfix~.
  - ~rename-mixfix~ :: Ignore outermost Agda argument markers ‚Äò_‚Äô
             when renaming an mixfix argument;
             e.g., ~_[_‚äó_]  ‚Ü¶  _‚ÇÄ[_‚äó_]¬π~ where this particular renaming
             is a prefix subscript 0 and postfix 1.

*** ~Itify~: A macro that makes macros ‚ô•‚Äø‚ô•
    :PROPERTIES:
    :CUSTOM_ID: -Itify---A-macro-that-makes-macros----
    :END:
    :PROPERTIES:

    :END:

   A common pattern I've observed is code of the form
   ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
   function ~f~ that is invoked with two arguments; the first being a
   function. The declaration ~(itify f~) will produce a macro named ~f-it~
   that takes two arguments where the first is an expression involving
   a free variable ~it~ such that
          | ~(f-it expr-with-it more)  ‚âà  (f (Œª (it) expr-with-it) more)~ |

 I'm only considering binary functions, since they're my most common
 case ---it's little trouble to move to the general case.

 Let's consider the simplest binary operator whose first argument is
 necessarily a function ---namely, function application.
 #+BEGIN_SRC emacs-lisp
(defun ap (f x) "bye" (funcall f x))
 #+END_SRC

 Let's form the desired macro:
 #+BEGIN_SRC emacs-lisp
(defmacro ap-it (itbody more)
  (list 'ap (list 'lambda '(it) itbody) more)
  ;; ‚âà `(ap (lambda (it) ,itbody) ,more)
  )
 #+END_SRC

 We have elected to present this with the ~list~ form
 rather than the quasi-quote, since it's clear how to
 yield the former as part of a macro /result/.

 #+BEGIN_SRC emacs-lisp :tangle yes
(defmacro itify (fname)
  "
   From a function (h f x), obtain a macro (h-it (‚ãØit‚ãØ) x) that rewrites into
   the orginal such that the first (functional) argument  may now be an expression
   with free variable ‚Äòit‚Äô. One declates (itify h) for a named top-level function ‚Äòh‚Äô.

   NOTE: Since functions are of the form (cons 'macro-or-fun (function (lambda args body)))
   we can obtain the number of args by getting ‚Äòargs‚Äô and taking its length.
   Then we can change any of its indices to take an expression rather than a function.
   Indeed, (macroexpand '(itify ap))
     ‚áí (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more)
         (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))      .
  "

  `(defmacro ,(intern (format "%s-it" (symbol-name fname))) (itbody more)
       (list (quote ,fname) (list 'lambda '(it) itbody) more))
)
 #+END_SRC

 Let's test this out.
 #+BEGIN_SRC emacs-lisp
;; 0. Too clunky
(ap (lambda (it) (+ 2 it)) 3) ;; ‚áí 5

;; 1. Desired
(itify ap)
(ap-it (+ 2 it) 3) ;; nice.

;; 2. Works with lambdas?
((lambda (e) (ap-it (+ 2 it) e)) 2)

;; 3. Scoping is fine?
;; Outermost ‚Äòit‚Äô belongs to --map; inner-most ‚Äòit‚Äô belongs to ap-it. (‚îÄ‚Äø‚Äø‚îÄ)
(--map (ap-it (+ 2 it) it) '(1 2 3)) ;; ‚áí (3 4 5)

;; 4. Works well with read/eval?
(ap-it (eval (car (read-from-string "(+ 2 it)"))) 3) ;; ‚áí 5
 #+END_SRC

 A common use of the following will be when ‚Äòthreads‚Äô are used for
 sequential processing.
 #+BEGIN_SRC emacs-lisp :tangle yes
(itify funcall)
 #+END_SRC

 Now for a more useful and complex setting.
 <<<rename-mixfix>>> source block here.

 {{{fold(Unit Tests)}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest rename-mixfix ()

  (should (equal (rename-mixfix #'identity "_‚äï_") "_‚äï_"))

  (should (equal "_‚äï‚Ä≤_" (rename-mixfix-it (eval (car (read-from-string "(concat it \"‚Ä≤\")"))) "_‚äï_")))

  (should  (equal (--map (rename-mixfix-it (format "‚ÇÄ%s¬π" it) it) '("_‚äï_" "_[_‚äó_]" "he_lo" "he-lo"))
       ;; Outermost ‚Äòit‚Äô belongs to --map; inner-most ‚Äòit‚Äô belongs to rename-mixfix-it.
  '("_‚ÇÄ‚äï¬π_" "_‚ÇÄ[_‚äó_]¬π" "‚ÇÄhe_lo¬π" "‚ÇÄhe-lo¬π"))))
 #+END_SRC
 {{{end-fold}}}
* Abstract                                                   :ignore:
:PROPERTIES:
:CUSTOM_ID: Abstract
:END:

# See https://shields.io/
#
# https://img.shields.io/badge/<LABEL>-<MESSAGE>-<COLOR>.svg
#
#+BEGIN_export html :tangle to-github?
<p align="center"><img src="emacs-logo.png" width=150 height=150/></p>
#+END_export
#+begin_src emacs-lisp :tangle no :exports results :wrap "export html" :results replace
(concat
"<p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
        <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
</p>")
#+end_src

#+RESULTS:
#+begin_export html
<p align="center">
        <a href="https://www.gnu.org/software/emacs/">
        <img src="https://img.shields.io/badge/GNU%20Emacs-26.1-b48ead.svg?style=plastic"/></a>
        <a href="https://orgmode.org/"><img src="https://img.shields.io/badge/org--mode-9.2.5-489a9f.svg?style=plastic"/></a>
</p>
#+end_export

#+begin_center org
*Abstract*
#+end_center

Herein I document the configurations I utilise with [[https://gnu.org/s/emacs][Emacs]].
# After cloning the file, many packages are automatically installed; usually with
# little or no trouble.

As a [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate program]] file with [[http://orgmode.org/][Org-mode]], I am ensured optimal navigation
through my ever growing configuration files, ease of usability and reference
for peers, and, most importantly, better maintainability for myself!

Dear reader, when encountering a foregin command ~X~ I encourage you to execute ~(describe-symbol 'X)~, or press ~C-h o~ with the cursor on ~X~.
An elementary Elisp Cheat Sheet can be found [[https://github.com/alhassy/ElispCheatSheet][here.]]

* Why Emacs?
:PROPERTIES:
:CUSTOM_ID: Why-Emacs?
:END:

/Emacs is a flexible platform for developing end-user applications/ --unfortunately it is generally perceived as
merely a text editor. Some people use it specifically for one or two applications.

For example, [[https://www.youtube.com/watch?v=FtieBc3KptU][writers]] use it as an interface for Org-mode and others use it as an interface for version
control with Magit. [[https://orgmode.org/index.html#sec-4][Org]] is an organisation tool that can be used for typesetting which subsumes LaTeX, generating many different
formats --html, latex, pdf, etc-- from a single source, keeping track of [[https://orgmode.org/worg/org-tutorials/index.html#orgff7b885][schedules]] & task management, blogging, habit tracking, personal information management tool, and [[http://orgmode.org/worg/org-contrib/][much more]].
Moreover, its syntax is so [[https://karl-voit.at/2017/09/23/orgmode-as-markup-only/][natural]] that most people use it without even knowing!
For me, Org allows me to do literate programming: I can program and document at the same time,
with no need to seperate the two tasks and with the ability to generate multiple formats and files from a single file.

#+begin_quote
If you are a professional writer‚Ä¶Emacs outshines all other editing software
in approximately the same way that the noonday sun does the stars.
It is not just bigger and brighter; it simply makes everything else vanish.
‚Äî[[http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/][Neal Stephenson]], /In the beginning was the command line/
#+end_quote

Of course Emacs comes with the basic features of a text editor, but it is much more;
for example, it comes with a powerful notion of ‚Äòundo‚Äô: Basic text editors have a single stream of undo,
yet in Emacs, we have a tree --when we undo and make new edits, we branch off in our editing stream
as if our text was being version controlled as we type! --We can even switch between such branches!

# Todo: Learn about weaving so that presentation order may differ from code tangeling order.
#
#
#+begin_src emacs-lisp :tangle no
;; Allow tree-semantics for undo operations.
(package-install 'undo-tree)
(global-undo-tree-mode)
(diminish 'undo-tree-mode)

;; Execute (undo-tree-visualize) then navigate along the tree to witness
;; changes being made to your file live!

;; Each node in the undo tree should have a timestamp.
(setq undo-tree-visualizer-timestamps t)

;; Show a diff window displaying changes between undo nodes.
(setq undo-tree-visualizer-diff t)
#+end_src

/Emacs is an extensible editor: You can make it into the editor of your dreams!/
You can make it suited to your personal needs.
If there's a feature you would like, a behaviour your desire, you can simply code that into Emacs with
a bit of Lisp. As a programming language enthusiast, for me Emacs is my default Lisp interpreter
and a customisable IDE that I use for other programming languages
--such as C, Haskell, Agda, Racket, and Prolog.
Moreover, being a Lisp interpreter, we can alter the look and feel of Emacs live, without having
to restart it --e.g., press ~C-x C-e~ after the final parenthesis of ~(scroll-bar-mode 0)~
to run the code that removes the scroll-bar.

#+begin_quote
/I use Emacs every day. I rarely notice it. But when I do, it usually brings me joy./
‚îÄ[[https://so.nwalsh.com/2019/03/01/emacs][Norman Walsh]]
#+end_quote

I have used Emacs as an interface for developing cheat sheets, for making my blog, and as an application
for ‚Äòinteractively learning C‚Äô. If anything Emacs is more like an OS than just a text editor
--‚Äúliving within Emacs‚Äù provides an abstraction over whatever operating system my machine has:
[[https://www.fugue.co/blog/2015-11-11-guide-to-emacs.html][It's so easy to take everything with me.]] Moreover, the desire to mould Emacs to my needs has made me
a better programmer: I am now a more literate programmer and, due to Elisp's documentation-oriented nature, I actually take the time
and effort to make meaningful documentation --even when the project is private and will likely only be seen by me.

#+begin_quote
/Seeing Emacs as an editor is like seeing a car as a seating-accommodation./ -- [[https://karl-voit.at/2015/10/23/Emacs-is-not-just-an-editor/][Karl Voit]]
#+end_quote
# Comparing Emacs to an editor is like comparing GNU/Linux to a word processor. -- [[https://karl-voit.at/2015/10/23/Emacs-is-not-just-an-editor/][Karl Voit]]

Some possibly interesting reads:
+ [[https://sachachua.com/blog/series/a-visual-guide-to-emacs/][How to Learn Emacs: A Hand-drawn One-pager for Beginners / A visual tutorial]]
+ [[http://emacsrocks.com/][Video Series on Why Emacs Rocks]] ---catch the enthusiasm!
+ [[http://ehneilsen.net/notebook/orgExamples/org-examples.html#sec-18][Emacs org-mode examples and cookbook]]
+ [[https://m00natic.github.io/emacs/emacs-wiki.html][An Opinionated Emacs guide for newbies and beyond]]
+ [[https://tuhdo.github.io/emacs-tutor.html][Emacs Mini-Manual, Part I of III]]
  # + The [[http://tuhdo.github.io/emacs-tutor.html#orgheadline63][Emacs Mini Manual]], or
+ [[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][Org and R Programming]] ---a tutorial on literate programming, e.g., evaluating code within ~src~ bloc.
+ Reference cards for [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf][GNU Emacs]], [[https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf][Org-mode]], and [[https://github.com/alhassy/ElispCheatSheet/blob/master/CheatSheet.pdf][Elisp]].
+ [[https://www.reddit.com/r/emacs/comments/6fytr5/when_did_you_start_using_emacs/][‚ÄúWhen did you start using Emacs‚Äù discussion on Reddit]]
+ [[https://david.rothlis.net/emacs/howtolearn.html][‚ÄúHow to Learn Emacs‚Äù]]
+ [[https://orgmode.org/index.html#sec-4][The Org-mode Reference Manual]] or [[https://orgmode.org/worg/][Worg: Community-Written Docs]] which includes a [[https://orgmode.org/worg/org-tutorials/index.html][meta-tutorial]].
+ [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]]: A community driven list of useful Emacs packages, libraries and others.
+ [[https://github.com/caisah/emacs.dz][A list of people's nice emacs config files]]
#  + [[https://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][Stackexchange: Using org-mode to structure config files]]

---If eye-candy, a sleek and beautiful GUI, would entice you then consider starting with [[http://spacemacs.org/][spacemacs]].
   Here's a helpful [[https://www.youtube.com/watch?v=hCNOB5jjtmc][installation video]], after which you may want to watch
   [[https://www.youtube.com/watch?v=PVsSOmUB7ic][Org-mode in Spacemacs]] tutorial---

Remember: Emacs is a flexible platform for developing end-user applications; e.g., this configuration file
is at its core an Emacs Lisp program that yields the editor of my dreams
--it encourages me to grow and to be creative, and I hope the same for all who use it;
moreover, it reflects my personality such as what I value and what I neglect in my workflow.

# why emacs ---not marching to someone-else's tune!
#+begin_quote org
/I‚Äôm stunned that you, as a professional software engineer, would eschew inferior computer languages that hinder your ability to craft code,
/but you put up with editors that bind your fingers to someone else‚Äôs accepted practice. --- [[http://www.howardism.org/Technical/Emacs/why-emacs.html][Howard Abrams]]
#+end_quote

Moreover, as will be shown below, you can literrally use [[https://github.com/zachcurry/emacs-anywhere/#usage][Emacs anywhere]]
for textually input in your operating system --no copy-paste required.

Finally, here's some fun commands to try out:
+ ~M-x doctor~ ---generalising the idea of rubber ducks
+ ~M-x tetris~  or ~M-x gomoku~ or ~M-x snake~---a break with a classic
+ ~M-x butterfly~ ---in reference to [[https://xkcd.com/378/][‚Äúreal programmers‚Äù]]

* Booting Up
:PROPERTIES:
:CUSTOM_ID: Booting-Up
:END:
Let's always load local variables that we've marked as safe.
( I tend to use loads of such locals! )
#+BEGIN_SRC emacs-lisp
(setq enable-local-variables :safe)
#+END_SRC

** ~~/.emacs~ vs. ~init.org~
:PROPERTIES:
:CUSTOM_ID: ~~/.emacs~-vs.-~init.org~
:END:

Why not keep Emac's configurations in the ~~/.emacs~ file?
This is because the Emacs system may explicitly add, or alter, code
in it.

For example, execute the following
 0. ~M-x customize-variable RET line-number-mode RET~
   # (customize-variable 'line-number-mode)
 0. Then press: ~toggle~, ~state~, then ~1~.
 0. Now take a look: ~(find-file "~/.emacs")~
Notice how additions to the file have been created by `custom'.

As such, I've chosen to write my Emacs' initialisation configurations
in a file named ~~/.emacs.d/init.org~: I have a literate configuration which
is then loaded using org-mode's tangling feature.
Read more about Emacs' initialisation configurations [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File][here.]]

Off topic, I love tiling window managers and had been using [[https://xmonad.org][xmonad]]
until recently when I obtained a mac machine and now use
[[https://ianyh.com/amethyst/][Amethyst]] -- ‚ÄúTiling window manager for macOS along the lines of xmonad.‚Äù

Let the Emacs' gui insert default configurations and customisation
into its own file, not touching or altering my initialisation file.
For example, I tend to have local variables to produce ~README.md~'s
and other matters, so Emacs' Custom utility will remember to not prompt
me each time for the safety of such local variables.
#+begin_src emacs-lisp
(-let [custom "~/.emacs.d/custom.el"]
  (unless (file-exists-p custom)
    (eshell-command (format "touch %s" custom)))
  (setq custom-file custom)
  (load custom-file))
#+end_src

Rather than manually extracting the Lisp code from this literate document
each time we alter it, let's instead add a ‚Äòhook‚Äô ---a method  that is invoked
on a particular event, in this case when we save the file.
More precisely, in this case, ~C-x C-s~ is a normal save whereas
~C-u C-x C-s~ is a save after forming ~init.elc~ and ~README.md~.

#+name: enable making init and readme
#+BEGIN_SRC emacs-lisp :eval never-export
  (defun my/make-init-el-and-README ()
    (interactive "P") ;; Places value of universal argument into: current-prefix-arg
    (when current-prefix-arg
      (let (org-export-use-babel)
        (save-excursion
          ;; Make init.el
          (org-babel-tangle)
          (byte-compile-file "~/.emacs.d/init.el")
          (load-file "~/.emacs.d/init.el")

          ;; Make README.md
          (org-babel-goto-named-src-block "make-readme")
          (org-babel-execute-src-block)

          (message "Tangled, compiled, and loaded init.el; and made README.md")))))

  (add-hook 'after-save-hook 'my/make-init-el-and-README nil 'local-to-this-file-please)
#+END_SRC

#+RESULTS: enable making init and readme
:results:
(my/make-init-el-and-README t)
:end:

Where the following block has ~#+NAME: make-readme~ before it.
This source block generates the ~README~ for the associated github repository.

# [[https://orgmode.org/manual/JavaScript-support.html][JavaScript supported display of web pages]]
# INFOJS_OPT: view:info toc:t buttons:t
#
# Looks nice for standalone pages; doesn't incorporate
# nicely with github README.md.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp :tangle no :export_never t
(with-temp-buffer
    (insert (concat
    "#+EXPORT_FILE_NAME: README.md
     #+HTML: <h1> A Life Configuring Emacs </h1>
     #+begin_export html
     <p align=\"center\">
       <img src=\"emacs-logo.png\" width=150 height=150/>
     </p>

     <p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
             <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
     </p>

     <p align=\"center\">
       <img src=\"emacs-birthday-present.png\" width=200 height=250/>
     </p>
     #+end_export
     #+HTML: <h3> My Literate Setup </h3>
     #+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     I enjoy reading others' /literate/ configuration files and incorporating what I learn
     into my own. The result is a sufficiently well-documented and accessible read that yields
     a stylish and functional system (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

     This ~README.md~ has been automatically generated from my configuration
     and its contents below could also be read in blog format, with /colour/, or as colourful PDF,
     [[https://alhassy.github.io/init/][here]]. Enjoy :smile:

      #+TOC: headlines 2
      #+INCLUDE: init.org
    "))
    (org-mode)
    (org-md-export-to-markdown)
    ;; Coloured html does not work in Github, afaik.
    ;; (org-html-export-to-html)
    ;; (shell-command "mv README.html README.md")
)
#+END_SRC

#+RESULTS: make-readme
:results:
README.md
:end:

** TODO COMMENT Elementary Version Control
:PROPERTIES:
:CUSTOM_ID: COMMENT-Elementary-Version-Control
:END:
:Properties:
:TODO: Make some of these eshell commands that are executed?
       Usage would be to simply C-x C-e the fragment to have
       all of these transpire for you ^_^
:End:

[[http://www.linfo.org/hard_link.html][Soft links]] are pointers to other filenames, whereas hardlinks
are pointers to memory location of a given filename!
Soft links are preferable since they defer to the orginal filename
and can work across servers.

We can declare them as follows,
#+BEGIN_EXAMPLE shell
ln -s source_file myfile
#+END_EXAMPLE

If ~repo~ refers to a directory under version control
--or Dropbox-- we move our init file and emacs directory to it,
then make soft links to these locations so that whenever ~~/.emacs~
is accessed it will refer to ~repo/.emacs~ and likewise for ~.emacs.d~ :-)

On a new machine, copy-paste any existing emacs configs we want
to the ~repo~ folder then ~rm -rf ~~/.emacs*~ and then make the soft
links only.

#+BEGIN_EXAMPLE shell
repo=~/Dropbox     ## or my git repository: ~/dotfiles

cd ~

mv .emacs $repo/
ln -s $repo/.emacs .emacs

mv .emacs.elc $repo/
ln -s $repo/.emacs.elc .emacs.elc

mv .emacs.d/ $repo/
ln -s $repo/.emacs.d/ .emacs.d
#+END_EXAMPLE
Note the extra ~/~ after ~.emacs.d~!

You may need to unlink soft links if you already have them;
e.g., ~unlink .emacs.d~.

To make another softlink to a file, say in a blogging directory,
we ~cd~ to the location of interest then execute, say:
~ln -s $repo/.emacs.d/init.org init.org~

While we're at it, let's make this super-duper file (and another) easily
accessible --since we'll be altering it often--:
#+BEGIN_EXAMPLE shell
cd ~

ln -s dotfiles/.emacs.d/init.org init.org
ln -s alhassy.github.io/content/AlBasmala.org AlBasmala.org
#+END_EXAMPLE

Below I'll equip us with an Emacs ‚Äòporcelain‚Äô interface to git
--it makes working with version control tremendously convenient.
Moreover, I add a little pop-up so that I don't forget to commit often!

** TODO COMMENT What's in, or at the top of, my ~~/.emacs~
:PROPERTIES:
:CUSTOM_ID: COMMENT-What's-in,-or-at-the-top-of,-my-~~/.emacs~
:END:

We evaluate every piece of emacs-lisp code available here when
Emacs starts up by placing the following at the top of our ~.emacs~ file:
#+BEGIN_SRC emacs-lisp :tangle no
(org-babel-load-file "~/.emacs.d/init.org")
;;
;; My Emacs settings: (find-file "~/.emacs.d/init.org")
#+END_SRC
( I do not generate my ~.emacs~ file from this source code in-fear of
   overriding functionality inserted by ~custom~. )

# Whenever this ~init.org~ is loaded by org-babel it creates a ~.emacs~ file which
Our ~.emacs~ should be byte-compiled so that when we start Emacs it will
automatically determine if the ~init.org~ file has changed and if so it
would tangle it producing the ~init.el~ file which will then be loaded immediately.

:Maybe_bad_idea:
#+BEGIN_SRC emacs-lisp :tangle no
;; In-case I forget to byte-compile!
(byte-compile-file "~/.emacs")

;; Change this silly counter to visualy notice a change. When making many changes.
;; (progn (message "Init.org contents loaded! Counter: 7") (sleep-for 3))
#+END_SRC
:End:

** ~use-package~ --The start of ~init.el~
:PROPERTIES:
:CUSTOM_ID: ~use-package~---The-start-of-~init.el~
:END:

:Stuff_in_dot_emacs:
#+begin_src emacs-lisp
;; In ~/.emacs
;;
;; (require 'package)
;; (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
;; (package-initialize)
;; (require 'org-tempo)
;;
#+end_src
:End:

There are a few ways to install packages
--run ~C-h C-e~ for a short overview.
The easiest, for a beginner, is to use the command ~package-list-packages~
then find the desired package, press ~i~ to mark it for installation, then
install all marked packages by pressing ~x~.

Alternatively, one uses the declarative configuration tool [[https://github.com/jwiegley/use-package/][use-package]]
--a meta-package that manages other packages and the way they interact.

Background:
Recently I switched to mac --first time trying the OS.
I had to do a few ~package-install~'s and it was annoying.
I'm looking for the best way to package my Emacs installation
--inlcuding my installed pacakages and configuration--
so that I can quickly install it anywhere, say if I go to another machine.
It seems ~use-package~ allows me to configure and auto install packages.
On a new machine, when I clone my ~.emacs.d~ and start emacs,
on the first start it should automatically install and compile
all of my packages through ~use-package~ when it detects they're missing.

# The following block should be the top-most loaded items.

First we need the basic ~package~ module which not only allows us to obtain ~use-package~ but
acts as its kernel.
#+BEGIN_SRC emacs-lisp
;; Make all commands of the ‚Äúpackage‚Äù module present.
(require 'package)

;; Speef up start up by not loading any packages at startup.
;; (setq package-enable-at-startup nil)
;; Look at the *Messages* buffer before setting this to nil, then after.

;; (setq gnutls-algorithm-priority nil) "NORMAL:-VERS-TLS1.3")

;; Internet repositories for new packages.
(setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "http://melpa.org/packages/")
                         ("melpa-stable" . "http://stable.melpa.org/packages/")
                         ;; Maintainer is AWOL.
                         ;; ("marmalade" . "https://marmalade-repo.org/packages/")
                         ))

;; Actually get ‚Äúpackage‚Äù to work.
(package-initialize)

(package-refresh-contents)
#+END_SRC

#+RESULTS:

We can now:
+ ~M-x list-packages~ to see all melpa packages that can install
  - Not in alphabetical order, so maybe search with ~C-s~.
+ For example to download the haskell mode: ~M-x package-install RET haskell-mode RET~.
  - Or maybe to install ~unicode-fonts~ ;-)
+ Read more at http://ergoemacs.org/emacs/emacs_package_system.html or
  at https://github.com/milkypostman/melpa

:Faq:
If there are issues with loading the archives,
say, "Failed to download ‚Äògnu‚Äô archive."
then ensure you can both read and write, recursively, to your .emacs.d/
E.g., within emacs try to execute (package-refresh-contents)
and you'll observe a permissions error.
:End:

We now bootstrap ~use-package~,
#+BEGIN_SRC emacs-lisp
;; Unless it's already installed, update the packages archives,
;; then install the most recent version of ‚Äúuse-package‚Äù.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC

#+RESULTS:
: use-package

We can now invoke ~(use-package XYZ :ensure t)~
which should check for the ~XYZ~ package and make sure it is accessible.
If not, the ~:ensure t~ part tells ~use-package~ to download it
--using ~package.el~--
and place it somewhere accessible, in ~~/.emacs.d/elpa/~ by default.

By default we would like to download packages, since I do not plan on installing them manually
by download ~.el~ files and placing them in the correct places on my system.
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src

#+RESULTS:
: t

Here's an example use of ~use-package~.
Below I have my ‚Äúshow recent files pop-up‚Äù command set to ~C-x C-r~;
but what if I forget? This mode shows me all key completions when I type ~C-x~, for example.
Moreover, I will be shown other commands I did not know about! Neato :-)
#+BEGIN_SRC emacs-lisp
;; Making it easier to discover Emacs key presses.
(use-package which-key
 :diminish which-key-mode
 :init (which-key-mode)
 :config (which-key-setup-side-window-bottom)
         (setq which-key-idle-delay 0.05)
)
#+END_SRC

#+RESULTS:
: t

The ~:diminish~ keyword indicates that we do not want the mode's name to be
shown to us in the modeline --the area near the bottom of Emacs.
It does so by using the ~diminish~ package, so let's install that.
#+begin_src emacs-lisp
(use-package diminish)

;; Let's hide some markers.
(diminish 'eldoc-mode)
(diminish 'org-indent-mode)
(diminish 'subword-mode)
#+end_src

Here are other packages that I want to be installed onto my machine.

#+BEGIN_SRC emacs-lisp
;; Efficient version control.
(use-package magit
  :config (global-set-key (kbd "C-x g") 'magit-status)
)

(use-package htmlize)
;; Main use: Org produced htmls are coloured.
;; Can be used to export a file into a coloured html.

(use-package biblio)     ;; Quick BibTeX references, sometimes.

;; Get org-headers to look pretty! E.g., * ‚Üí ‚äô, ** ‚Ü¶ ‚óØ, *** ‚Ü¶ ‚òÖ
;; https://github.com/emacsorphanage/org-bullets
(use-package org-bullets)
(add-hook 'org-mode-hook 'org-bullets-mode)

(use-package haskell-mode)

(use-package dash)    ;; ‚ÄúA modern list library for Emacs‚Äù
(use-package s   )    ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù.
#+END_SRC

Note:
+ [[https://github.com/magnars/dash.el][dash]]: ‚ÄúA modern list library for Emacs‚Äù
  - E.g., ~(--filter (> it 10) (list 8 9 10 11 12))~
+ [[https://github.com/magnars/s.el][s]]: ‚ÄúThe long lost Emacs string manipulation library‚Äù.
  - E.g., ~s-trim, s-replace, s-join~.

Finally, since I've symlinked my ~.emacs~:
#+begin_src emacs-lisp
;; Don't ask for confirmation when opening symlinked files.
(setq vc-follow-symlinks t)
#+end_src

** ~magit~ --Emacs' porcelain interface to git
:PROPERTIES:
:CUSTOM_ID: ~magit~---Emacs'-porcelain-interface-to-git
:END:

Why use ~magit~ as the interface to the git version control system?
In a magit buffer nearly everything can be acted upon:
Press ~return,~ or ~space~, to see details and ~tab~ to see children items, usually.

#+BEGIN_SRC emacs-lisp
;; See here for a short & useful tutorial:
;; https://alvinalexander.com/git/git-show-change-username-email-address
(when (equal ""
(shell-command-to-string "git config user.name"))
  (shell-command "git config --global user.name \"Musa Al-hassy\"")
  (shell-command "git config --global user.email \"alhassy@gmail.com\""))
#+END_SRC

# Execute ~M-x dired~ to see the contents of a particular directory.
#
Below is my personal quick guide to working with magit.
A quick magit tutorial can be found on [[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]]

+ ~magit-init~ :: Put a project under version control.
  The mini-buffer will prompt you for the top level folder version.
  A ~.git~ folder will be created there.

+ ~magit-status~ , ~C-x g~ :: See status in another buffer. Press ~?~ to see options,
     including:
  - ~q~ :: Quit magit, or go to previous magit screen.
  - ~s~ :: Stage, i.e., add, a file to version control.
         Add all untracked files by selecting the /Untracked files/ title.
  - ~k~ :: Kill, i.e., delete a file locally.
  - ~K~ :: This' ~(magit-file-untrack)~ which does ~git rm --cached~.
  - ~i~ :: Add a file to the project ~.gitignore~ file. Nice stuff =)
  - ~u~ :: Unstage a specfif staged change highlighed by cursor.
           ~C-u s~ stages everything --tracked or not.
  - ~c~ :: Commit a change.
    * A new buffer for the commit message appears, you write it then
      commit with ~C-c C-c~ or otherwise cancel with ~C-c C-k~.
      These commands are mentioned to you in the minibuffer when you go to commit.
    * You can provide a commit to /each/ altered chunk of text!
      This is super neat, you make a series of local such commits rather
      than one nebulous global commit for the file. The ~magit~ interface
      makes this far more accessible than a standard terminal approach!
    * You can look at the unstaged changes, select a /region/, using ~C-SPC~ as usual,
      and commit only that if you want!
    * When looking over a commit, ~M-p/n~ to efficiently go to previous or next altered sections.
    * Amend a commit by pressing ~a~ on ~HEAD~.

  - ~d~ :: Show differences, another ~d~ or another option.
    - This is magit! Each hunk can be acted upon; e.g., ~s~ or ~c~ or ~k~ ;-)
    - [[https://softwareengineering.stackexchange.com/a/119807/185815][The staging area is akin to a pet store; commiting is taking the pet home.]]
  - ~v~ :: Revert a commit.
  - ~x~ :: Undo last commit. Tantamount to ~git reset HEAD~~ when cursor is on most recent
           commit; otherwise resets to whatever commit is under the cursor.
  - ~l~ :: Show the log, another ~l~ for current branch; other options will be displayed.
    - Here ~space~ shows details in another buffer while cursour remains in current
      buffer and, moreover, continuing to press ~space~ scrolls through the other buffer!
      Neato.
  - ~P~ :: Push.
  - ~F~ :: Pull.
  - ~:~ :: Execute a raw git command; e.g., enter ~whatchanged~.

  The status buffer may be refereshed using ~g~, and all magit buffer by ~G~.
  # E.g., when you make git changes outside of emacs.
  Press ~tab~ to see collapsed items, such as what text has been changed.

Notice that every time you press one of these commands, a ‚Äòpop-up‚Äô of realted git options
appears! Thus not only is there no need to memorize many of them, but this approach makes
discovering other commands easier.

Use ~M-x (magit-list-repositories) RET~ to list local repositories:

Below are the git repos I'd like to clone.
#+begin_src emacs-lisp
(use-package magit)

;; Do not ask about this variable when cloning.
(setq magit-clone-set-remote.pushDefault t)

(cl-defun maybe-clone (remote &optional (local (concat "~/" (file-name-base remote))))
  "Clone a ‚Äòremote‚Äô repository if the ‚Äòlocal‚Äô directory does not exist.
    Yields ‚Äònil‚Äô when no cloning transpires, otherwise yields ‚Äúcloned-repo‚Äù.

    ‚Äòlocal‚Äô is optional and defaults to the base name; e.g.,
    if ‚Äòremote‚Äôis ‚Äòhttps://github.com/X/Y‚Äô then ‚Äòlocal‚Äô becomes ‚Äò~/Y‚Äô.
  "
  (if (file-directory-p local)

     'repo-already-exists

     (async-shell-command (concat "git clone " remote " " local))
     (add-to-list 'magit-repository-directories `(,local   . 0))
     'cloned-repo)
)

;; Set variable without asking.
(setq magit-clone-set-remote.pushDefault 't)

;; Public repos
(maybe-clone "https://github.com/alhassy/emacs.d" "~/.emacs.d")
(maybe-clone "https://github.com/alhassy/alhassy.github.io")
(maybe-clone "https://github.com/alhassy/ElispCheatSheet")
(maybe-clone "https://github.com/alhassy/RubyCheatSheet")
(maybe-clone "https://github.com/alhassy/FSharpCheatSheet")
(maybe-clone "https://github.com/alhassy/CatsCheatSheet")
(maybe-clone "https://github.com/alhassy/org-agda-mode")
(maybe-clone "https://github.com/JacquesCarette/TheoriesAndDataStructures")
(maybe-clone "https://github.com/alhassy/islam")
(maybe-clone "https://gitlab.cas.mcmaster.ca/armstmp/cs3mi3.git" "~/3mi3")
#+end_src
:Other_repos_I_use:
#+begin_src emacs-lisp
(maybe-clone "https://github.com/alhassy/CheatSheet")

(maybe-clone "https://github.com/alhassy/OCamlCheatSheet")
(maybe-clone "https://github.com/alhassy/PrologCheatSheet")

(maybe-clone "https://github.com/alhassy/MyUnicodeSymbols")
(maybe-clone "https://github.com/alhassy/interactive-way-to-c")
(maybe-clone "https://github.com/alhassy/next-700-module-systems-proposal.git" "~/thesis-proposal")
(maybe-clone "https://github.com/JacquesCarette/MathScheme")
(maybe-clone "https://github.com/alhassy/gentle-intro-to-reflection" "~/reflection/")

;; Private repos

(maybe-clone "https://gitlab.cas.mcmaster.ca/schaapal/metaocaml-kwic.git" "~/alex") ;; metaprogramming, ocaml, phd
(maybe-clone "https://gitlab.cas.mcmaster.ca/MathScheme/TheoryPresentations.git" "~/yasmine") ;; theory presentations, scala, phd
(maybe-clone "https://gitlab.cas.mcmaster.ca/MathScheme/Differentiating-Programs.git" "~/noel") ;; calculus for datatypes, phd

;;
(maybe-clone "https://gitlab.cas.mcmaster.ca/alhassm/CAS781" "~/cas781") ;; cat adventures
;;
;; (maybe-clone "https://gitlab.cas.mcmaster.ca/carette/cs3fp3.git" "~/3fp3")
;; (maybe-clone "https://gitlab.cas.mcmaster.ca/RATH/RATH-Agda"     "~/RATH-Agda")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/assignment-distribution.git" "~/3ea3/assignment-distribution")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/notes.git" "~/3ea3/notes")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/assignment-development.git" "~/3ea3/assignment-development")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/kandeeps.git" "~/3ea3/sujan")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/horsmane.git" "~/3ea3/emily")
(maybe-clone "https://gitlab.cas.mcmaster.ca/3ea3-winter2019/anderj12.git" "~/3ea3/jacob")
;; (maybe-clone "https://gitlab.cas.mcmaster.ca/alhassm/3EA3.git" "~/3ea3/_2018")
;; (maybe-clone "https://gitlab.cas.mcmaster.ca/2DM3/LectureNotes.git" "~/2dm3")

;; Likely want to put a hook when closing emacs, or at some given time,
;; to show me this buffer so that I can ‚Äòpush‚Äô if I haven't already!
;
; (magit-list-repositories)
#+end_src
:End:

Let's always notify ourselves of a file that has [[https://tpapp.github.io/post/check-uncommitted/][uncommited changes]]
--we might have had to step away from the computer and forgotten to commit.
#+begin_src emacs-lisp
(require 'magit-git)

(defun my/magit-check-file-and-popup ()
  "If the file is version controlled with git
  and has uncommitted changes, open the magit status popup."
  (let ((file (buffer-file-name)))
    (when (and file (magit-anything-modified-p t file))
      (message "This file has uncommited changes!")
      (when nil ;; Became annyoying after some time.
      (split-window-below)
      (other-window 1)
      (magit-status)))))

;; I usually have local variables, so I want the message to show
;; after the locals have been loaded.
(add-hook 'find-file-hook
  '(lambda ()
      (add-hook 'hack-local-variables-hook 'my/magit-check-file-and-popup)
   ))
#+end_src
Let's try this out:
#+BEGIN_EXAMPLE emacs-lisp
(progn (eshell-command "echo change-here >> ~/dotfiles/.emacs")
       (find-file "~/dotfiles/.emacs")
)
#+END_EXAMPLE

In doubt, execute ~C-h e~ to jump to the ~*Messages*~ buffer.

Finally, one of the main points for using version control is to have
access to historic versions of a file. The following utility
allows us to ~M-x git-timemachine~ on a file and use ~p/n/g/q~ to look
at previous, next, goto arbitrary historic versions, or quit.
- If we want to roll back to a previous version, we just ~write-file~ as usual!
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine)
#+END_SRC

** Fix spelling as you type --thesaurus & dictionary too!
:PROPERTIES:
:CUSTOM_ID: Fix-spelling-as-you-type---thesaurus-&-dictionary-too!
:END:
I would like to check spelling by default.
 + ~C-;~ :: Cycle through corrections for word at point.
 + ~M-$~ :: Check and correct spelling of the word at point
 + ~M-x ispell-change-dictionary RET TAB~ :: To see what dictionaries are available.

# Emacs includes Flyspell. You must not explicitly install it. If you do so, undo this,
# that is, delete flyspell.el from /Applications/Emacs.app/Contents/Resources/site-lisp.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :hook (
           (prog-mode . flyspell-prog-mode)
           (text-mode . flyspell-mode))
)
#+END_SRC
# (add-hook 'text-mode-hook 'flyspell-mode)

Enabling fly-spell for text-mode enables it for org and latex modes since they
derive from text-mode.

Flyspell needs a spell checking tool, which is not included in Emacs.
We install ~aspell~ spell checker using, say, homebrew via ~brew install aspell~.
Note that Emacs' ~ispell~ is the interface to such a command line spelling utility.
# See available dictionary via ~aspell dicts~.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/local/bin/aspell")
(setq ispell-dictionary "en_GB") ;; set the default dictionary

(diminish 'flyspell-mode) ;; Don't show it in the modeline.
#+END_SRC

:ignore_for_now:
Allow spelling support for CamlCase words like ‚ÄúEmacsIsCool‚Äù.
#+BEGIN_SRC emacs-lisp :tangle no
(setq  ispell-extra-args '("--sug-mode=ultra"
                            "--run-together"
                            "--run-together-limit=5"
                            "--run-together-min=2"))
#+END_SRC
:End:

:Hook_TODO:
Hook for after init?
(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
:End:

:Old_global_flyspell:
Not a good idea...

;; Maybe a hook is better? Much better ...?
(define-globalized-minor-mode my-flyspell-global-mode flyspell-mode
  (lambda ()

    ;; spawns an ispell process
    (flyspell-mode 1)

))
(my-flyspell-global-mode 1)

:End:

Let us select a correct spelling merely by clicking on a word.
#+begin_src emacs-lisp
(eval-after-load "flyspell"
  ' (progn
     (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
     (define-key flyspell-mouse-map [mouse-3] #'undefined)))
#+end_src

Colour incorrect works; default is an underline.
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
(custom-set-faces '(flyspell-incorrect ((t (:inverse-video t)))))
#+END_SRC

Finally, save to user dictionary without asking:
#+BEGIN_SRC emacs-lisp
(setq ispell-silently-savep t)
#+END_SRC

Let's keep track of my personal word set by having it be in my version controlled
.emacs directory. [[http://aspell.net/man-html/Format-of-the-Personal-and-Replacement-Dictionaries.html][Note]] that the default location is ~~/.[i|a]spell.DICT~ for
a specified dictionary ~DICT~.
#+BEGIN_SRC emacs-lisp
(setq ispell-personal-dictionary "~/.emacs.d/.aspell.en.pws")
#+END_SRC

Nowadays, I very rarely write non-literate programs, but if I do
I'd like to check spelling only in comments/strings. E.g.,
#+BEGIN_SRC emacs-lisp
(add-hook          'c-mode-hook 'flyspell-prog-mode)
(add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode)
#+END_SRC

Use the thesaurus Emacs frontend [[https://github.com/hpdeifel/synosaurus][Synosaurus]] to avoid unwarranted repetition.
#+begin_src emacs-lisp
(use-package synosaurus
  :diminish synosaurus-mode
  :init    (synosaurus-mode)
  :config  (setq synosaurus-choose-method 'popup) ;; 'ido is default.
           (global-set-key (kbd "M-#") 'synosaurus-choose-and-replace)
)
#+end_src
The thesaurus is powered by the Wordnet ~wn~ tool, which can be invoked without an internet connection!
#+begin_src emacs-lisp
;; (shell-command "brew cask install xquartz &") ;; Dependency
;; (shell-command "brew install wordnet &")
#+end_src

Let's use Wordnet as a dictionary via the [[https://github.com/gromnitsky/wordnut][wordnut]] package.
#+BEGIN_SRC emacs-lisp
(use-package wordnut
 :bind ("M-!" . wordnut-lookup-current-word))

;; Use M-& for async shell commands.
#+END_SRC
Use ~M-‚Üë,‚Üì~ to navigate dictionary results, and ~wordnut-search~ for a new search.
#
# I'm using Wordnet for the dictionary since I'm also using it for the thesaurus.
# An alternative is to use the lightweight ~define-word~ library; which I think
# is not ideal since it provides way less info compared to wn.
#

:CurrentlyNotWorking:
#+BEGIN_SRC emacs-lisp :tangle no
(load "~/dotfiles/.emacs.d/powerthesaurus.el")
(global-set-key (kbd "M-#") 'powerthesaurus-lookup-word-at-point)

;; Website currently down ... https://github.com/SavchenkoValeriy/emacs-powerthesaurus/issues/6
#+END_SRC
:End:

Use this game to help you learn to spell words that you're having trouble with;
see ~~/Dropbox/spelling.txt~.
#+BEGIN_SRC emacs-lisp
(autoload 'typing-of-emacs "~/.emacs.d/typing.el" "The Typing Of Emacs, a game." t)
#+END_SRC

Practice touch typing using [[https://github.com/hagleitn/speed-type][speed-type]].
#+begin_src emacs-lisp
(use-package speed-type)
#+end_src
Running ~M-x speed-type-region~ on a region of text, or ~M-x speed-type-buffer~ on a
whole buffer, or just ~M-x speed-type-text~ will produce the selected region, buffer,
or random text for practice. The timer begins when the first key is pressed
and stats are shown when the last letter is entered.

Other typing resources include:
+ [[https://www.emacswiki.org/emacs/TypingOfEmacs][Typing of Emacs]] --an Emacs alternative to speed type, possibly more engaging.
+ [[https://alternativeto.net/software/klavaro/][Klavaro]] --a GUI based yet language-independent typing tutor.
  - I'm enjoying this tool in getting started with Arabic typing.
  - The plan is to move to using the online [[https://makinghijrah.com/arabic-typing/][Making Hijrah]] tutor which
    concludes the basic lesson plan with a few short narrations.
+ [[https://typing.io/][Typing.io]] is a tutor for coders: Lessons are based on open source code, such
  some XMonad written in Haskell or Linux written in  C.
+ [[https://www.gnu.org/software/gtypist/index.html#downloading][GNU Typist]] --which is interactive in the terminal, so not ideal in Emacs--,

To assist in language learning, it may be nice to have an Emacs
[[https://github.com/atykhonov/google-translate][interface]] to Google translate ---e.g., invoke ~google-translate-at-point~.
#+BEGIN_SRC emacs-lisp
(use-package google-translate
 :config
   (global-set-key "\C-ct" 'google-translate-at-point)
)
#+END_SRC

Select the following then ~C-c t~,
#+begin_quote
Hey buddy, what're you up to?
#+end_quote
Then /detect language/ then /Arabic/ to obtain:
#+begin_quote
ŸÖÿ±ÿ≠ÿ®ÿßŸã Ÿäÿß ÿµÿØŸäŸÇŸä ÿå ŸÖÿßÿ∞ÿß ÿ™ŸÅÿπŸÑÿü
#+end_quote
Neato üò≤

** Using a Grammar & Style Checker
:PROPERTIES:
:CUSTOM_ID: Using-a-Grammar-&-Style-Checker
:END:

Let's install [[https://github.com/mhayashi1120/Emacs-langtool][a grammar and style checker]].
We get the offline tool from the bottom of the [[https://languagetool.org/][LanguageTool]] website, then relocate it
as follows.
#+BEGIN_SRC emacs-lisp
(use-package langtool
 :config
  (setq langtool-language-tool-jar
     "~/Applications/LanguageTool-4.5/languagetool-commandline.jar")
)
#+END_SRC

Now we can run ~langtool-check~ on the subsequent grammatically incorrect
text ---which is from the LanguageTool website--- which colours errors in red,
when we click on them we get the reason why; then we may invoke
~langtool-correct-buffer~ to quickly use the suggestions to fix each correction,
and finally invoke ~langtool-check-done~ to stop any remaining red colouring.

#+begin_example org
LanguageTool offers spell and grammar checking. Just paste your text here
and click the 'Check Text' button. Click the colored phrases for details
on potential errors. or use this text too see an few of of the problems
that LanguageTool can detecd. What do you thinks of grammar checkers?
Please not that they are not perfect. Style issues get a blue marker:
It's 5 P.M. in the afternoon. The weather was nice on Thursday, 27 June 2017
--uh oh, that's the wrong date ;-)
#+end_example

By looking around the source code, I can do all three stages smoothly (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
#+BEGIN_SRC emacs-lisp
;; Quickly check, correct, then clean up /region/ with M-^

(add-hook 'langtool-error-exists-hook
  (lambda ()
    (langtool-correct-buffer)
    (langtool-check-done)
  ))

(global-set-key "\M-^" (lambda () (interactive) (message "Grammar checking begun ...") (langtool-check)))
#+END_SRC

The checking command is silent, we added a bit of comforting acknowledgement to the user.

** Unicode Input via Agda Input
:PROPERTIES:
:CUSTOM_ID: Unicode-Input-via-Agda-Input
:END:

:agda2-include-dirs-Issue:
#+BEGIN_SRC emacs-lisp
; (load (shell-command-to-string "agda-mode locate"))
;;
;; Seeing: One way to avoid seeing this warning is to make sure that agda2-include-dirs is not bound.
; (makunbound 'agda2-include-dirs)
#+END_SRC
:End:

[[https://mazzo.li/posts/AgdaSort.html][Agda]] is one of my favourite languages, it's like Haskell on steroids.
Let's set it up.

Executing ~agda-mode setup~ appends the following text to the ~.emacs~ file.
Let's put it here ourselves.
#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "/usr/local/bin/agda-mode locate")))
#+end_src

I almost always want the ~agda-mode~ input method.

#+BEGIN_SRC emacs-lisp
(require 'agda-input)
(add-hook 'text-mode-hook (lambda () (set-input-method "Agda")))
(add-hook 'org-mode-hook (lambda () (set-input-method "Agda")))
#+END_SRC

:agda_Command_line_arguments:
    "+RTS   -H4.5G   -M4.5G   -K256M   -S/tmp/AgdaRTS.log   -A1G   -RTS   -i   ."

Wolfram Kahl has recommended the following settings.

#+begin_src emacs-lisp
;;(setq agda2-program-args (quote ("RTS" "-M4G" "-H4G" "-A128M" "-RTS")))
#+end_src

These arguments specify
| ~+RTS~, ~-RTS~ | Flags between these are arguments to the ~ghc~ runtime |
| ~-M[size]~   | Maximum heap size                                    |
| ~-H[size]~   | Suggested heap size                                  |
| ~-A[size]~   | Allocation area size used by the garbage collector   |

Full documentation for the ~ghc~ runtime argumentscan be found [[https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html][here]].

Additional arguments that may be useful include
| ~-S[file]~ | Produces information about ‚Äúeach and every garbage collection‚Äù |
|          | - Outputs to ~stderr~ by default                               |

:end:

Below are my personal Agda input symbol translations;
e.g., ~\set ‚Üí ùíÆ‚ÑØùìâ~. Note that we could give a symbol new Agda TeX binding
interactively: ~M-x customize-variable agda-input-user-translations~ then
~INS~ then for key sequence type ~set~ then ~INS~ and for string paste ~ùíÆ‚ÑØùìâ~.
#+BEGIN_SRC emacs-lisp
(add-to-list 'agda-input-user-translations '("set" "ùíÆ‚ÑØùìâ"))
#+END_SRC
Better yet, as a loop:
#+BEGIN_SRC emacs-lisp
(loop for item in
      '(
        ;; categorial
        ("alg" "ùíúùìÅ‚Ñä")
        ("split" "‚ñµ")
        ("join" "‚ñø")
        ("adj" "‚ä£")
        (";;" "Ôπî")
        (";;" "‚®æ")
        (";;" "‚àò")
        ;; lattices
        ("meet" "‚äì")
        ("join" "‚äî")
        ;; residuals
        ("syq"  "‚ï≥")
        ("over" "‚ï±")
        ("under" "‚ï≤")
        ;; Z-quantification range notation, e.g., ‚Äú‚àÄ x ‚ùô R ‚Ä¢ P‚Äù
        ("|" "‚ùô")
        ("with" "‚ùô")
        ;; adjunction isomorphism pair
        ("floor"  "‚åä‚åã")
        ("lower"  "‚åä‚åã")
        ("lad"    "‚åä‚åã")
        ("ceil"   "‚åà‚åâ")
        ("raise"  "‚åà‚åâ")
        ("rad"    "‚åà‚åâ")
        ;; more (key value) pairs here
        )
      do (add-to-list 'agda-input-user-translations item))
#+END_SRC
Also some silly stuff:
#+BEGIN_SRC emacs-lisp
;; angry, cry, why-you-no
(add-to-list 'agda-input-user-translations
   '("whyme" "·Éö(‡≤†Áõä‡≤†)·Éö" "„ÉΩ‡ºº‡≤¢_‡≤¢‡ºΩÔæâ‚òÇ" "—â(„Çú„É≠„Çú—â)"))
;; confused, disapprove, dead, shrug
(add-to-list 'agda-input-user-translations
   '("what" "„Äå(¬∞„Éò¬∞)" "(‡≤†_‡≤†)" "(‚úñ‚ï≠‚ïÆ‚úñ)" "¬Ø\\_(„ÉÑ)_/¬Ø"))
;; dance, csi
(add-to-list 'agda-input-user-translations
   '("cool" "‚îè(-_-)‚îì‚îè(-_-)‚îõ‚îó(-_-Ôªø )‚îì" "‚Ä¢_‚Ä¢)
( ‚Ä¢_‚Ä¢)>‚åê‚ñ†-‚ñ†
(‚åê‚ñ†_‚ñ†)
"))
;; love, pleased, success, yesss
(add-to-list 'agda-input-user-translations
   '("smile" "‚ô•‚Äø‚ô•" "(‚îÄ‚Äø‚Äø‚îÄ)" "(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà" "(‡∏á‡≤†_‡≤†)‡∏á"))
#+END_SRC

# If you change this setting manually, without using the
# customization buffer, you need to call (agda-input-setup) in
# order for the change to take effect.
Finally let's effect such translations.
#+begin_src emacs-lisp
;; activate translations
(agda-input-setup)
#+end_src

#+RESULTS:

Note that the effect of [[http://ergoemacs.org/emacs/emacs_n_unicode.html][Emacs unicode input]] could be approximated using
~abbrev-mode~.

:May_need_to_install_stix_font:
;; install STIX font from Ubuntu store!!
;; (set-fontset-font t 'unicode (font-spec :name "STIX") nil 'append)
:End:

** COMMENT Locally ~toggle~ a variable :not_needed:
:PROPERTIES:
:FIXME: This utility should accept a sequence of forms, possibly utilise a progn?
:CUSTOM_ID: COMMENT-Locally-~toggle~-a-variable
:END:

*todo* body of toggle should be a progn?

It is dangerous to load a file with local variables;
instead we should load files without evaluating locals,
read the locals to ensure they are safe --e.g., there's nothing
malicious like ~eval: (delete-file your-important-file.txt)~--
then revert the buffer to load the locals.

However, when preprocessing my own files I sometimes wish
to accept all locals without being queried and so have the following
combinator.

#+begin_src emacs-lisp
(defmacro toggle (variable value &rest code)
  "Locally set the value of ‚Äòvariable‚Äô to be ‚Äòvalue‚Äô in the scope of ‚Äòcode‚Äô.
   In particular, the value of ‚Äòvariable‚Äô, if any, *is* affected
   to produce useful sideffects. It retains its orginal value outside this call.

   This is a feature of Lisp's dynamic scope.
   Essentilly this macro behaves like a let-statement with one item;
   rather than use, say ‚Äú-let‚Äù, I've used a possibly more informative name.

   Example uses include terse replacements for one-off let-statements,
   or, more likely, of temporarily toggeling important values, such as
   ‚Äòkill-buffer-query-functions‚Äô for killing a process buffer without confirmation.

   Another example: ‚Äò(toggle enable-local-variables :all ‚ãØ)‚Äô to preprocess files
   without being queried about possibly dangerous local variables.
  "
  `(let ((,variable ,value))
        ,@code
  )
)
#+end_src

Since emacs-lisp interprets definitions sequentially, I define ~toggle~ here
since I employ it in the next section.

:Discussion:
#+begin_example emacs-lisp
;; example usage
(macroexpand '(toggle x "x" (message x)))

(toggle x "x" (message x))

(message x) ;; crashes since x is unassigned

;; Notice that let's overshadow names. Put this into ElispCheatSheet
;;
(progn
(setq NOPE "NOPE")
(let ((NOPE "YUP")) )
(message NOPE)
)

(toggle NOPE "x" (message x))

NOPE ;; ‚áí "NOPE"
#+end_example
:End:

** Syncing to the System's ~$PATH~
:PROPERTIES:
:CUSTOM_ID: Syncing-to-the-System's-~$PATH~
:END:

For one reason or another, on OS X it seems that an Emacs instance
begun from the terminal may not inherit the terminal's environment
variables, thus making it difficult to use utilities like ~pdflatex~
when Org-mode attempts to produce a PDF.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init
    (when (memq window-system '(mac ns x))
     (exec-path-from-shell-initialize))
)
#+end_src

See these [[https://github.com/purcell/exec-path-from-shell][docs]] for setting other environment variables.

:Explicit_solution:
#+BEGIN_SRC emacs-lisp :tangle no
;; https://emacs.stackexchange.com/questions/4090/org-mode-cannot-find-pdflatex-using-mac-os

(defun set-exec-path-from-shell-PATH ()
  "Sets the exec-path to the same value used by the user shell"
  (let ((path-from-shell
         (replace-regexp-in-string
          "[[:space:]\n]*$" ""
          (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))

;; call function now
(set-exec-path-from-shell-PATH)
#+END_SRC

#+RESULTS:
| /Users/musa/Library/Haskell/bin | /usr/local/bin | /usr/bin | /bin | /usr/sbin | /sbin | /Library/TeX/texbin | /usr/local/share/dotnet | /opt/X11/bin | /Library/Frameworks/Mono.framework/Versions/Current/Commands | /Users/musa/Library/Haskell/bin |
:End:

** Keeping My System Up to Date
:PROPERTIES:
:CUSTOM_ID: Keeping-My-System-Up-to-Date
:END:
#+BEGIN_SRC emacs-lisp
(defun my/stay-up-to-date ()

  "Ensure that OS and Emacs pacakges are up to date.

   Takes ~5 secons when everything is up to date.
  "

  (async-shell-command "brew update && brew upgrade")
  (other-window 1)
  (rename-buffer "Keeping-system-up-to-date")

  (package-refresh-contents)
  (insert "Emacs packages have been updated.")

  (other-window 1)
)

(add-hook 'after-init-hook 'my/stay-up-to-date)

;; For now, doing this since I'm also calling my/stay-up-to-date with
;; after-init-hook which hides the startup message.
(add-hook 'after-init-hook 'display-startup-echo-area-message)
#+END_SRC
** Who am I? ‚îÄUsing Gnus for Gmail
:PROPERTIES:
:CUSTOM_ID: Who-am-I?-‚îÄUsing-Gnus-for-Gmail
:END:
Let's set the following personal
Emacs-wide variables ‚îÄto be used in other locations besides email.
#+begin_src emacs-lisp
(setq user-full-name    "Musa Al-hassy"
      user-mail-address "alhassy@gmail.com")
#+end_src

By default, in Emacs, we may send mail: Write it in Emacs with ~C-x m~,
then press ~C-c C-c~ to have it sent via your OS's default mailing system
--mine appears to be Gmail via the browser. Or cancel sending mail with
~C-c C-k~ --the same commands for capturing, discussed below (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

To send and read email in Emacs we use
[[https://en.wikipedia.org/wiki/Gnus][GNUS]] --which, like many GNU itself, it a recursive acronym:
GNUS Network User Service.

  1. Execute, rather place in your init:
     #+begin_src emacs-lisp
     (setq message-send-mail-function 'smtpmail-send-it)
     #+end_src

     Revert to the default OS mailing method by setting this variable to
     ~mailclient-send-it~.

  2. Follow only the [[https://www.emacswiki.org/emacs/GnusGmail#toc1][quickstart here]]; namely, make a file named ~~/.gnus~ containing:
     #+begin_src emacs-lisp :tangle ~/.gnus
     ;; user-full-name and user-mail-address should be defined

(setq gnus-select-method
      '(nnimap "gmail"
               (nnimap-address "imap.gmail.com")
               (nnimap-server-port "imaps")
               (nnimap-stream ssl)))

(setq smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
     #+end_src

  3. Enable ‚Äú2 step authentication‚Äù for Gmail following [[https://emacs.stackexchange.com/a/33309/10352][these]] instructions.
     :Instructions_Verbatim:
     You need generate a password for your application only (Gnus, in this case).

See https://support.google.com/mail/answer/185833?hl=en

I finished setup for Gnus in 1 minute, even though I never use 2 step verification for Gmail before.

Enable 2 step verification, I did a quick search and went to https://myaccount.google.com/security. Just follow its step by step guide and submit the form

In order to setup Gmail app password, I googled the keyword and went to https://support.google.com/accounts/answer/185833?hl=en. Click the link "How to generate an App password", read the guide and click the link inside it. Login in with your google account

There is a "App" section inside dashboard, you can not miss it. Follow the guide.

I don't know what's your Gnus setup. To be honest, your question lacks the essential information. See https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org on how to setup Gnus.
:End:

  4. You will then obtain a secret password, the ~x~ marks below, which you insert in a file
     named ~~/.authinfo~ as follows --using your email address.
     #+begin_src
     machine imap.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port imaps
     machine smtp.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port 587
     #+end_src

  5. In Emacs, ~M-x gnus~ to see what's there.

     Or compose mail with ~C-x m~ then send it with ~C-c C-c~.
     - Press ~C-h m~ to learn more about message mode for mail composition;
       or read [[https://www.gnus.org/manual/message.pdf][the Message Manual]].

In gnus, by default items you've looked at disappear --i.e., are archived.
They can still be viewed in, say, the online browser if you like.
In the ~Group~ view, ~R~ resets gnus, possibly retriving mail or alterations
from other mail clients. ~q~ exits gnus in ~Group~ mode, ~q~ exits the particular
view to go back to summary mode. Only after pressing ~q~ from within a group
do changes take effect on articles --such as moves, reads, deletes, etc.

  + RET :: Open an article.

  + B m :: Move an article, in its current state, to another group
           --i.e., ‚Äòlabel‚Äô using Gmail parlance.

         Something to consider doing when finished with an article.

     To delete an article, simply move it to ‚Äòtrash‚Äô --of course this will delete it
     in other mail clients as well. There is no return from trash.

     Emails can always be achieved --never delete, maybe?

  + ! :: mark an article as read, but to be kept around
    --e.g., you have not replied to it, or it requires more reading at a later time.

  + R :: Reply to email with sender's content there in place.
    - ~r~ to reply to an email with sender's content in adjacent buffer.

  + d ::  mark an article as done, i.e., read it and it can be archived.

Learn more by reading [[https://www.gnus.org/manual.html][The Gnus Manual]]; also available within Emacs by ~C-h i m gnus~ (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

- Or look at the [[https://www.gnu.org/software/emacs/refcards/pdf/gnus-refcard.pdf][Gnus Reference Card]].
- Or, less comprehensively, this [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org#subscribe-groups][outline]].
** Emacs keybindings for my brower
:PROPERTIES:
:CUSTOM_ID: Emacs-keybindings-for-my-brower
:END:
I've downloaded the [[https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb/related][Vimium]] extension for Google Chrome,
and have copy-pasted [[https://gist.github.com/dmgerman/6f0e5f9ffc6484dfaf53][these]] Emacs key bindings into it.
Now ~C-h~ in my browser shows which Emacs-like bindings
can be used to navigate my browser ^_^

** Using Emacs in any text area on my OS
:PROPERTIES:
:CUSTOM_ID: Using-Emacs-in-any-text-area-on-my-OS
:END:

Using the [[https://github.com/zachcurry/emacs-anywhere/#usage][Emacs-Anywhere]] tool, I can press ~Cmd Shift e~ to have an Emacs frame
appear, produce text with Emacs editing capabilities, then ~C-x 5 0~ to have the
resulting text dumped into the text area I was working in.

This way I can use Emacs literally anywhere for textual input!

For my Mac OSX:
#+BEGIN_SRC emacs-lisp
(shell-command "curl -fsSL https://raw.github.com/zachcurry/emacs-anywhere/master/install | bash")

(server-start)
#+END_SRC

The tools that use emacs-anywhere --such as my web browser-- and emacs-anywhere
itself need to be given sufficient OS permissions:
#+begin_example org
System Preferences ‚Üí Security & Privacy ‚Üí Accessibility
#+end_example
Then check the emacs-anywhere box from the following gui and provide a keyboard shortcut:
#+begin_example org
System Preferences ‚Üí Keyboard ‚Üí Shortcuts ‚Üí Services
#+end_example

(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

I always want to be in Org-mode and input unicode:
#+BEGIN_SRC elisp
(add-hook 'ea-popup-hook
  (lambda (app-name window-title x y w h)
   (org-mode)
   (set-input-method "Agda")
  )
)
#+END_SRC

** Restarting Emacs
:PROPERTIES:
:CUSTOM_ID: Restarting-Emacs
:END:

Sometimes I wish to close then reopen Emacs; unsurprisingly someone's thought of implementing that.
#+BEGIN_SRC emacs-lisp
;; Provides only the command ‚Äúrestart-emacs‚Äù.
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC

* Cosmetics
:PROPERTIES:
:CUSTOM_ID: Cosmetics
:END:

# Font
# (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-12"))

:ExperimentingWithBackgroundColours:
Note: Using spacemacs theme above.

#+begin_src emacs-lisp :tangle no
;; try background colour for html:  ---nice soft yellow, pleasing---
;;
(add-to-list 'default-frame-alist '(background-color . "#fcf4dc"))
#+end_src

(set-background-color "white")
(set-background-color "#eae3cb")   -- a bit dark
(set-background-color "#fcf4dc")   -- nice!
:End:

#+begin_src emacs-lisp
;; Make it very easy to see the line with the cursor.
(global-hl-line-mode t)

;; Clean up any accidental trailing whitespace and in other places,
;; upon save.
(add-hook 'before-save-hook 'whitespace-cleanup)

;; Keep self motivated!
(setq frame-title-format '("" "%b - Living The Dream (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà"))
#+end_src
** Themes
:PROPERTIES:
:CUSTOM_ID: Themes
:END:
#+BEGIN_SRC emacs-lisp
;; Treat all themes as safe; no query before use.
(setf custom-safe-themes t)

;; Nice looking themes ^_^
(use-package solarized-theme :demand t)
(use-package doom-themes  :demand t)
(use-package spacemacs-common
    :ensure spacemacs-theme
    :config (load-theme 'spacemacs-light t))

(defun my/disable-all-themes ()
  (dolist (th custom-enabled-themes)
          (disable-theme th))
)

(defun my/load-dark-theme ()
  ;;   (load-theme 'spacemacs-dark)   ;; orginally
  (my/disable-all-themes)
  (load-theme 'doom-vibrant)
)

(defun my/load-light-theme ()
  (load-theme 'spacemacs-light)   ;; orginally
  ;; Recently I'm liking this ordered mixture.
  ;; (load-theme 'solarized-light) (load-theme 'doom-solarized-light)
)

;; ‚ÄúC-x t‚Äù to toggle between light and dark themes.
(defun my/toggle-theme () "Toggle between dark and light themes."
  (interactive)
  ;; Load dark if light is top-most enabled theme, else load light.
  (if (equal (car custom-enabled-themes) 'doom-vibrant)
      (my/load-light-theme)
      (my/load-dark-theme)
  )

  ;; The dark theme's modeline separator is ugly.
  ;; Keep reading below regarding ‚Äúpowerline‚Äù.
  ;; (setq powerline-default-separator 'arrow)
  ;; (spaceline-spacemacs-theme)
)

(global-set-key "\C-x\ t" 'my/toggle-theme)

;; Initially begin with the light theme.
; (ignore-errors (load-theme 'spacemacs-light t))
(my/toggle-theme)
#+END_SRC

The [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes]] also look rather appealing.
A showcase of many themes can be found [[https://emacsthemes.com/][here]].

** Startup message: Emacs & Org versions
:PROPERTIES:
:CUSTOM_ID: Startup-message:-Emacs-&-Org-versions
:END:
#+begin_src emacs-lisp
;; Silence the usual message: Get more info using the about page via C-h C-a.
(setq inhibit-startup-message t)

(defun display-startup-echo-area-message ()
  "The message that is shown after ‚Äòuser-init-file‚Äô is loaded."
  (message
      (concat "Welcome "      user-full-name
              "! Emacs "      emacs-version
              "; Org-mode "   org-version
              "; System "    (system-name)
                  (format "; Time %.3fs"
                      (float-time (time-subtract (current-time)
                                    before-init-time)))
      )
  )
)
#+end_src
Now my startup message is,
#+begin_src emacs-lisp
;; Welcome Musa Al-hassy! Emacs 26.1; Org-mode 9.2.3; System alhassy-air.local
#+end_src

For some fun, run this cute method.
#+BEGIN_SRC emacs-lisp :tangle no
(animate-birthday-present user-full-name)
#+END_SRC

Moreover, since I end up using org-mode most of the time, let's make that the default mode.
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC

:Why_not_cd_HOME:

+ Remark ::
  Not as useful as I orginally thought &&  magit doesn't recognise the git repo
  this init file belongs in easily.

One of the first things I normally do when I'm opening a file is to go to my
home directory. Let's stop being so repetitive by starting at the home directory.
#+BEGIN_SRC emacs-lisp :tangle no
;; Move to the user directory
(cd "~/")
#+END_SRC
:End:

** Persistent Scratch Buffer
:PROPERTIES:
:CUSTOM_ID: Persistent-Scratch-Buffer
:END:

The ~*scratch*~ buffer is a nice playground for temporary data.

I use Org-mode often, so that's how I want things to appear.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message (concat
  "#+Title: Persistent Scratch Buffer"
  "\n#\n # Welcome! This‚Äô a place for trying things out. \n"))
#+END_SRC

We might accidentally close this buffer, so we could utilise the following.
#+BEGIN_SRC emacs-lisp
;; A very simple function to recreate the scratch buffer:
;; ( http://emacswiki.org/emacs/RecreateScratchBuffer )
(defun scratch ()
   "create a scratch buffer"
   (interactive)
   (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
   (insert initial-scratch-message)
   (org-mode))

;; This doubles as a quick way to avoid the common formula: C-x b RET *scratch*
#+END_SRC

However, by default its contents are not saved --which may be an issue if we have
not relocated our playthings to their appropriate files. Whence let's save & restore
the scratch buffer by default.
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC

** Spaceline: A sleek mode line
:PROPERTIES:
:CUSTOM_ID: Spaceline:-A-sleek-mode-line
:END:

I may not use the spacemacs [[https://www.emacswiki.org/emacs/StarterKits][starter kit]], since I do not like evil-mode and find spacemacs
to ‚Äúhide things‚Äù from me --whereas Emacs ‚Äú‚Äùencourages‚Äù me to learn more--,
however it is a configuration and I enjoy reading Emacs configs in order to
improve my own setup. From Spacemacs I've adopted Helm for list completion,
its sleek light & dark themes, and its modified powerline setup.

The ‚Äòmodeline‚Äô is a part near the bottom of Emacs that gives information
about the current mode, as well as other matters --such as time & date, for example.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :config
  (require 'spaceline-config)
  (setq spaceline-buffer-encoding-abbrev-p nil)
  (setq spaceline-line-column-p nil)
  (setq spaceline-line-p nil)
  (setq powerline-default-separator 'arrow)
  :init
 (spaceline-helm-mode) ;; When using helm, mode line looks prettier.
 ; (ignore-errors (spaceline-spacemacs-theme))
)
#+END_SRC
Other separators I've considered include ~'brace~ instead of an arrow,
and ~'contour, 'chamfer, 'wave, 'zigzag~ which look like browser tabs
that are curved, boxed, wavy, or in the style of driftwood.

** Flashing when something goes wrong ‚îÄno blinking
:PROPERTIES:
:CUSTOM_ID: Flashing-when-something-goes-wrong-‚îÄno-blinking
:END:
Make top and bottom of screen flash when something unexpected happens thereby observing a warning message in the minibuffer. E.g., C-g, or calling an unbound key sequence, or misspelling a word.
#+BEGIN_SRC emacs-lisp
(setq visible-bell 1)
;; Enable flashing mode-line on errors
;; On MacOS, this shows a caution symbol ^_^

;; Blinking cursor rushes me to type; let's slow down.
(blink-cursor-mode -1)
#+END_SRC

** My to-do list: The initial buffer when Emacs opens up
:PROPERTIES:
:CUSTOM_ID: My-to-do-list:-The-initial-buffer-when-Emacs-opens-up
:END:
#+BEGIN_SRC emacs-lisp
(find-file "~/Dropbox/todo.org")
;; (setq initial-buffer-choice "~/Dropbox/todo.org")

(split-window-right)			  ;; C-x 3
(other-window 1)                              ;; C-x 0
;; toggle enable-local-variables :all           ;; Load *all* locals.
    ;; toggle org-confirm-babel-evaluate nil    ;; Eval *all* blocks.
      (find-file "~/.emacs.d/init.org")
#+END_SRC

:primitive_approach_to_recent_files:
#+BEGIN_SRC emacs-lisp :tangle no
;; List recently accessed files upon startup

(recentf-mode 1)                   ;; Part of Emacs
(setq recentf-max-menu-items 25)
(global-set-key "\C-x\ \C-r" 'recentf-open-files)

(when nil ;; nil since I don't use this feature often enough.
  (split-window-below)			  ;; C-x 3
  (other-window 1)                                ;; C-x 0
  (recentf-open-files)
)
#+END_SRC
:end:
** Showing date, time, and battery life
:PROPERTIES:
:CUSTOM_ID: Showing-date,-time,-and-battery-life
:END:
#+BEGIN_SRC emacs-lisp
(setq display-time-day-and-date t)
(display-time)

;; (display-battery-mode 1)
;; Nope; let's use a fancy indicator ‚Ä¶

(use-package fancy-battery
  :diminish
  :config
    (setq fancy-battery-show-percentage t)
    (setq battery-update-interval 15)
    (fancy-battery-mode)
    (display-battery-mode)
)
#+END_SRC

This will show remaining battery life, coloured green if charging
and coloured yellow otherwise. It is important to note that
this package is no longer maintained. It works on my machine.

** Hiding Scrollbar, tool bar, and menu
:PROPERTIES:
:CUSTOM_ID: Hiding-Scrollbar,-tool-bar,-and-menu
:END:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+END_SRC

** Increase/decrease text size
:PROPERTIES:
:CUSTOM_ID: Increase/decrease-text-size
:END:
# and word wrapping

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
  ;; C-x C-0 restores the default font size

(add-hook 'text-mode-hook
            '(lambda ()
               (visual-line-mode 1)
                   (diminish 'visual-line-mode)
               ))
#+END_SRC

:Ignore:

Reason: It seems on a file of ~10,000 lines, having this enabled
         results in notable lag for Helm! To investigate at a later date.

         The culprit may be fci-mode, as it is reported in the profiler.


Show ruler at 80 characters, for text and prog mode.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package fill-column-indicator)
(add-hook 'text-mode-hook 'fci-mode)
(add-hook 'prog-mode-hook 'fci-mode)
#+END_SRC

:End:

** Delete Selection mode
:PROPERTIES:
:CUSTOM_ID: Delete-Selection-mode
:END:
Delete Selection mode lets you treat an Emacs region much like a typical text
selection outside of Emacs: You can replace the active region.
We can delete selected text just by hitting the backspace key.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Highlight & complete parenthesis pair when cursor is near ;-)
:PROPERTIES:
:CUSTOM_ID: Highlight-&-complete-parenthesis-pair-when-cursor-is-near-;-)
:END:

#+begin_src emacs-lisp
;; Highlight expression within matching parens when near one of them.
(setq show-paren-delay 0)
(setq blink-matching-paren nil)
(setq show-paren-style 'expression)
(show-paren-mode)

;; Colour parens, and other delimiters, depending on their depth.
;; Very useful for parens heavy languages like Lisp.
(use-package rainbow-delimiters)

(add-hook 'org-mode-hook
  '(lambda () (rainbow-delimiters-mode 1)))
(add-hook 'prog-mode-hook
  '(lambda () (rainbow-delimiters-mode 1)))
#+end_src

For example,
#+begin_src emacs-lisp :tangle no
(blue (purple (forest (green (yellow (blue))))))
#+end_src

There is a powerful package called ‚Äòsmartparens‚Äô for working with pair-able
characters, but I've found it to be too much for my uses. Instead I'll utilise
the lightweight package ~electric~, which provided by Emacs out of the box.

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

It supports, by default, ACSII pairs ~{}, [], ()~ and Unicode ~‚Äò‚Äô, ‚Äú‚Äù, ‚ü™‚ü´, ‚ü®‚ü©~.

When writing Lisp, it is annoyong to have ‚Äò<‚Äô and ‚Äò>‚Äô be completed
/and/ considered as pairs.
Let's disassociate them from both notions.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-inhibit-predicate
      (lambda (c)
        (or (member c '(?< ?>)) (electric-pair-default-inhibit c))))

(when (< 1 2) 'bye)

;; Act as usual unless a ‚Äò<‚Äô or ‚Äò>‚Äô is encountered.
;; ( char-at is really ‚Äúcharacter at poisition‚Äù; C-h o! )
(setq rainbow-delimiters-pick-face-function
      (lambda (depth match loc)
        (unless (member (char-after loc) '(?< ?>))
          (rainbow-delimiters-default-pick-face depth match loc))))

;; Final piece.
(modify-syntax-entry ?< "(>")
(modify-syntax-entry ?> ")<")
#+END_SRC
:Test:
#+BEGIN_SRC emacs-lisp :tangle no
(rainbow-delimiters-mode 1)
(when (> 1 2) 'bye)

(1- 3)
#+END_SRC
:End:

Let's add the org-emphasises markers.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs
         '(
           (?~ . ?~)
           (?* . ?*)
           (?/ . ?/)
          ))
#+END_SRC

Let's also, for example, avoid obtaining double ‚Äò~‚Äô and ‚Äò/‚Äô when searching for a file.
#+BEGIN_SRC emacs-lisp
;; Disable pairs when entering minibuffer
(add-hook 'minibuffer-setup-hook (lambda () (electric-pair-mode 0)))

;; Renable pairs when existing minibuffer
(add-hook 'minibuffer-exit-hook (lambda () (electric-pair-mode 1)))
#+END_SRC

*** COMMENT Smartparens                                                        :Nope:
:PROPERTIES:
:CUSTOM_ID: COMMENT-Smartparens
:END:
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :init
  (smartparens-global-mode 1)
  (show-smartparens-global-mode +1)

  :bind (

         ("M-f" . sp-forward-sexp)  ;; Move forward one  expression.
         ("M-b" . sp-backward-sexp) ;; Move backward one expression.

         ;; Going to the start & end of current expr in pair-able character.
         ("M-a" . sp-beginning-of-sexp)
         ("M-e" . sp-end-of-sexp)

         ;; Going forwards deep down & up current expr; treating it as a tree.
         ("M-d" . sp-down-sexp)
         ("M-u" . sp-up-sexp)
         ;; Acending & descending backwards; i.e., leftwards.
         ("M-n" . sp-backward-down-sexp)
         ("M-p" . sp-backward-up-sexp)

         ;; Unwrapping: Removing pair-able characters.
         ("M-w" . sp-unwrap-sexp)
         ("M-m" . sp-backward-unwrap-sexp)

         ;; ‚ÄúSlurping‚Äù: Move closing character forward/backward to include next sexp.
         ;; ‚ÄúBarfing‚Äù: Contract a sexp, or string, by pushing a its last/first item out.
         ;; See below for examples.
         ("M-)" . sp-forward-slurp-sexp)
         ("M-(" . sp-backward-slurp-sexp)
         ("M-]" . sp-forward-barf-sexp)
         ("M-[" . sp-backward-barf-sexp)

         ;; Transpose two bracketed terms; e.g., a b c ‚ü™Here‚ü´ ‚ü∂ a c b ‚ü™Here‚ü´
         ;; Transpose backwards by being on the token;
         ;; transpose forwards by being after the token.
         ("M-t" . sp-transpose-sexp)

         )

  :config
  ;; Enable smartparens everywhere
  (use-package smartparens-config)

  (setq
   ;; smartparens-strict-mode t
   ;; sp-autoinsert-if-followed-by-word t
   ;; sp-autoskip-closing-pair 'always
   sp-hybrid-kill-entire-symbol nil)

  ;; In Elisp & org modes, do not ‚Äòclose‚Äô a back-tick or single quote!
  (sp-local-pair 'emacs-lisp-mode "`" nil :when '(sp-in-string-p))
  (sp-local-pair 'emacs-lisp-mode "'" nil :when '(sp-in-string-p))
  (sp-local-pair 'org-mode "`" nil :when '(sp-in-string-p))
  (sp-local-pair 'org-mode "'" nil :when '(sp-in-string-p))
  )
#+END_SRC

*Wrapping*
To enclose a token with a pair-able character, at the start of the expression
press ~C-ESCAPE-SPACE~, select the region, followed by a pair-able character such as ~[, {, ", ', *,~ etc.
To wrap a single token forwards, use ~C-M-SPACE~.

Examples of slurping & barfing --i.e., sexp inclusion and contraction.
#+begin_example
a [x y z] b  ‚ü∂‚ÄúM-) inside [‚ãØ]‚Äù‚ü∂  a [x y z b]
a [x y z] b  ‚ü∂‚ÄúM-) inside [‚ãØ]‚Äù‚ü∂  [a x y z] b
[a x y z b]  ‚ü∂‚ÄúM-] inside [‚ãØ]‚Äù‚ü∂  a [x y z b]
[a x y z b]  ‚ü∂‚ÄúM-] inside [‚ãØ]‚Äù‚ü∂  [a x y z] b
#+end_example

** Minibuffer should display line and column numbers
:PROPERTIES:
:CUSTOM_ID: Minibuffer-should-display-line-and-column-numbers
:END:
#+BEGIN_SRC emacs-lisp
; (line-number-mode t)
(column-number-mode t)
#+END_SRC

For line numbers on the side of the buffer:
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode t)

;; Have a uniform width for displaying line numbers,
;; rather than having the width grow as necessary.
(setq display-line-numbers-width-start t)
#+END_SRC

** Never lose the cursor
:PROPERTIES:
:CUSTOM_ID: Never-lose-the-cursor
:END:
Reduce mental strain of locating the cursour when navigation happens;
e.g., when we switch windows or scroll, we get a wave of light near the cursor.
#+begin_src emacs-lisp
(use-package beacon
  :ensure t
  :demand t
  :init
  (setq beacon-color "#666600")
  :config (beacon-mode))
#+end_src
** Neotree: Directory Tree Listing
:PROPERTIES:
:CUSTOM_ID: Neotree:-Directory-Tree-Listing
:END:
We open a nifty file manager upon startup.
#+BEGIN_SRC emacs-lisp
;; neotree --sidebar for project file navigation
(use-package neotree
  :config (global-set-key "\C-x\ d" 'neotree-toggle))

;; Only do this once:
(when nil
  (use-package all-the-icons)
  (all-the-icons-install-fonts 'install-without-asking))

(setq neo-theme 'icons)
(neotree-refresh)

;; Open it up upon startup.
(neotree-toggle)
#+END_SRC
By default ~C-x d~ invokes ~dired~, but I prefer ~neotree~ for file management.

Useful navigational commands include
+ ~U~ to go up a directory.
+ ~C-c C-c~ to change directory focus; ~C-C c~ to type the directory out.
+ ~?~ or ~h~ to get help and ~q~ to quit.

As always, to go to the neotree pane when it's the only other window,
execute ~C-x o~.

I /rarely/ make use of this feature; company mode & Helm together quickly provide
an automatic replacement for nearly all of my uses.

** Tabs :Disabled:
:PROPERTIES:
:CUSTOM_ID: Tabs
:END:
I really like my Helm-supported ~C-x b~, but the visial appeal of a [[https://github.com/manateelazycat/awesome-tab][tab bar]] for Emacs
is interesting. Let's try it out and see how long this lasts ---it may be like Neotree:
Something cute to show to others, but not as fast as the keyboard.

#+BEGIN_SRC emacs-lisp :tangle no
; (async-shell-command
;  "git clone --depth=1 https://github.com/manateelazycat/awesome-tab.git  ~/.emacs.d/elpa/awesome-tab")

(load-file "~/.emacs.d/elpa/awesome-tab/awesome-tab.el")

;; Show me /all/ the tabs at once, in one group.
(defun awesome-tab-buffer-groups ()
  (list (awesome-tab-get-group-name (current-buffer))))

(awesome-tab-mode t)
#+END_SRC

It's been less than three days and I've found this utility to be unhelpful, to me anyhow.

** Window resizing using the golden ratio :Disabled:
:PROPERTIES:
:CUSTOM_ID: Window-resizing-using-the-golden-ratio
:END:

Let's load the following package, which automatically resizes windows so that
the window containing the cursor is the largest, according to the golden ratio.
Consequently, the window we're working with is nice and large yet the other windows
are still readable.

#+begin_src emacs-lisp :tangle no
(use-package golden-ratio
  :diminish golden-ratio-mode
  :init (golden-ratio-mode 1))
#+end_src

After some time this got a bit annoying and I'm no longer  using this.

* Life within Org-mode
:PROPERTIES:
:CUSTOM_ID: Life-within-Org-mode
:END:

:Updating_FAQ:

#+BEGIN_SRC emacs-lisp :tangle no
(shell-command "rm ~/.emacs.d/elpa/org-9.2.3/*.elc")
(byte-recompile-directory "~/.emacs.d/elpa/org-9.2.3/")
#+END_SRC

Easiest way get latest version of org-mode:
~M-x package-list-packages~, then select ~org~, then ~install~.

https://stackoverflow.com/questions/31855904/emacs-sees-the-directory-with-the-new-org-mode-version-but-loads-the-old-versio

https://emacs.stackexchange.com/questions/27597/how-to-update-org-to-latest-version-using-package-repos-git-clone-in-ubuntu
:End:

Let's obtain Org-mode along with the extras that allow us to ignore
heading names, but still utilise their contents --e.g., such as a heading
named ‚Äòpreamble‚Äô that contains org-mode setup for a file.
#+begin_src emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].
+ Use the ~:noexport:~ tag to omit a headline /and/ its contents.

Now, let's replace the content marker, ‚Äú‚ãØ‚Äù, with a nice
unicode arrow.
#+begin_src emacs-lisp
(setq org-ellipsis " ‚§µ")
#+end_src
Also:
#+begin_src emacs-lisp
;; Fold all source blocks on startup.
(setq org-hide-block-startup t)

;; Lists may be labelled with letters.
(setq org-list-allow-alphabetical t)

;; Avoid accidentally editing folded regions, say by adding text after an Org ‚Äú‚ãØ‚Äù.
(setq org-catch-invisible-edits 'show)

;; I use indentation-sensitive programming languages.
;; Tangling should preserve my indentation.
(setq org-src-preserve-indentation t)

;; Tab should do indent in code blocks
(setq org-src-tab-acts-natively t)

;; Give quote and verse blocks a nice look.
(setq org-fontify-quote-and-verse-blocks t)

;; Pressing ENTER on a link should follow it.
(setq org-return-follows-link t)
#+END_SRC

I rarely use tables, but here is a useful [[http://notesyoujustmightwanttosave.blogspot.com/][Org-Mode Table Editing Cheatsheet]]
and a [[http://www.howardism.org/Technical/Emacs/spreadsheet.html][friendly tutorial]].

** High Speed Literate Programming
:PROPERTIES:
:CUSTOM_ID: High-Speed-Literate-Programming
:END:

*** Manipulating Sections
:PROPERTIES:
:CUSTOM_ID: Manipulating-Sections
:END:

Let's enable the [[http://notesyoujustmightwanttosave.blogspot.com/2011/12/org-speed-keys.html][Org Speed Keys]] so that when the cursor is at the beginning of
a headline, we can perform fast manipulation & navigation using the standard Emacs movement
controls, such as
+ ~#~ toggle ~COMMENT~-ing for an org-header.
+ ~s~ toggles ‚Äúnarrowing‚Äù to a subtree; i.e., hide the rest of the document.

  If you narrow to a subtree then any export, ~C-c C-e~, will only consider
  the narrowed detail.

+ ~I/O~ clock In/Out to the task defined by the current heading.
   - Keep track of your work times!
   - ~v~ view agenda.
+ ~u~ for jumping upwards to the parent heading.
+ ~c~ for cycling structure below current heading, or ~C~ for cycling global structure.
+ ~i~ insert a new same-level heading below current heading.
+ ~w~ refile current heading; options list pops-up to select which heading to move it to. Neato!
+ ~t~ cycle through the available TODO states.
+ ~^~ sort children of current subtree; brings up a list of sorting options.
+ ~n/p~ for next/previous /visible/ heading.
+ ~f/b~ for jumping forward/backward to the next/previous /same-level/ heading.
+ ~D/U~ move a heading down/up.
+ ~L/R~ recursively promote (move leftwards) or demote (more rightwards) a heading.
+ ~1,2,3~ to mark a heading with priority, highest to lowest.

We can add our own speed keys by altering the ~org-speed-commands-user~ variable.

Moreover, ~?~ to see a complete list of keys available.
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC
#  Add more speed commands by adding to this association list.
#  (describe-symbol 'org-speed-commands-user)
#
#  To see the commands available, execute
# (org-speed-command-help)

*** Seamless Navigation Between Source Blocks
:PROPERTIES:
:CUSTOM_ID: Seamless-Navigation-Between-Source-Blocks
:END:

Finally, let's use the ‚Äúsuper key‚Äù --aka the command or windows key--
to jump to the previous, next, or toggle editing org-mode source blocks.
#+begin_src emacs-lisp
;; Overriding keys for printing buffer, duplicating gui frame, and isearch-yank-kill.
;;
(define-key org-mode-map (kbd "s-p") #'org-babel-previous-src-block)
(define-key org-mode-map (kbd "s-n") #'org-babel-next-src-block)
(define-key org-mode-map (kbd "s-e") #'org-edit-src-code)
(define-key org-src-mode-map (kbd "s-e") #'org-edit-src-exit)
#+end_src

Interestingly, ~s-l~ is ‚Äúgoto line‚Äù.

*** Modifying ~<return>~
:PROPERTIES:
:CUSTOM_ID: Modifying-~<return>~
:END:

+ ~C-RET, C-S-RET~ make a new heading where the latter marks it as a ~TODO~.
+ By default ~M-RET~ makes it easy to work with existing list items, headings, tables, etc
  by creating a new item, heading, etc.
+ Usually we want a newline then we indent, let's make that the default.
   #+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook '(lambda ()
  (local-set-key (kbd "<return>") 'org-return-indent))
  (local-set-key (kbd "C-M-<return>") 'electric-indent-just-newline))
#+END_SRC

   Notice that I've also added another kind of return, for when I want to
   break-out of the indentation approach and start working at the beginning of
   the line.

In summary,
| key          | method                                  | behaviour                         |
|--------------+-----------------------------------------+-----------------------------------|
| ~<return>~     | ~org-return-indent~                       | Newline with indentation          |
| ~M-<return>~   | ~org-meta-return~                         | Newline with new org item         |
| ~C-M-<return>~ | ~electric-indent-just-newline~            | Newline, cursor at start          |
| ~C-<return>~   | ~org-insert-heading-respect-content~      | New heading /after/ current content |
| ~C-S-<return>~ | ~org-insert-todo-heading-respect-content~ | Ditto, but with a ~TODO~ marker     |

*** ~C-a,e,k~ and Yanking of sections
:PROPERTIES:
:CUSTOM_ID: ~C-a,e,k~-and-Yanking-of-sections
:END:
# Editing & Special Key Handling
#+begin_src emacs-lisp
;; On an org-heading, C-a goes to after the star, heading markers.
;; To use speed keys, run C-a C-a to get to the star markers.
;;
;; C-e goes to the end of the heading, not including the tags.
;;
(setq org-special-ctrl-a/e t)

;; C-k no longer removes tags, if activated in the middle of a heading's name.
(setq org-special-ctrl-k t)

;; When you yank a subtree and paste it alongside a subtree of depth ‚Äòd‚Äô,
;; then the yanked tree's depth is adjusted to become depth ‚Äòd‚Äô as well.
;; If you don't want this, then refile instead of copy pasting.
(setq org-yank-adjusted-subtrees t)
#+end_src

:Does_not_work_for_me:
;; adds alphabetical lists like
;;  a. item one
;;  b. item two
(setq org-alphabetical-lists t)
:End:

** Using org-mode as a Day Planner
:PROPERTIES:
:CUSTOM_ID: Using-org-mode-as-a-Day-Planner
:END:

- Rescheduled from "[2011-07-24 Sun]" on [2019-09-20 Fri 15:09]
‚ü™ This section is based on a dated, yet delightful, tutorial
  of the same title by [[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley]]. ‚ü´

We want a day-planner with the following use:
0. ‚ÄúMindlessly‚Äù & rapidly create new tasks.
1. Schedule and archive tasks at the end, or start, of the work day.
2. Glance at a week's tasks, shuffle if need be.
3. Prioritise the day's tasks. Aim for ‚â§15 tasks.
4. Progress towards ~A~ tasks completion by documenting work completed.
5. Repeat! During the day, if anything comes up, capture it and intentionally
   forget about it.

[[https://orgmode.org/org.html#Setting-up-capture][Capture]] lets me quickly make notes & capture ideas, with associated reference material,
without any interruption to the current work flow. Without losing focus on what you're doing,
quickly jot down a note of something important that just came up.

E.g., I have a task, or something I wish to note down, rather than opening
some file, then making a heading, then writing it; instead, I press
~C-c c t~ and a pop-up appears, I make my note, and it disappears with my
notes file(s) now being altered! Moreover, by default it provide a timestamp
and a link to the file location where I made the note --helpful for tasks, tickets,
to be tackled later on.

#+begin_src emacs-lisp
(setq org-default-notes-file "~/Dropbox/todo.org")
(define-key global-map "\C-cc" 'org-capture)
#+end_src

By default we only get a ‚Äòtasks‚Äô form of capture, let's add some more.
#+begin_src emacs-lisp
(cl-defun my/make/org-capture-template
   (shortcut heading &optional (no-todo nil) (description heading) (category heading) (scheduled t))
  "Quickly produce an org-capture-template.

  After adding the result of this function to ‚Äòorg-capture-templates‚Äô,
  we will be able perform a capture with ‚ÄúC-c c ‚Äòshortcut‚Äô‚Äù
  which will have description ‚Äòdescription‚Äô.
  It will be added to the tasks file under heading ‚Äòheading‚Äô
  and be marked with category  ‚Äòcategory‚Äô.

  ‚Äòno-todo‚Äô omits the ‚ÄòTODO‚Äô tag from the resulting item; e.g.,
  when it's merely an interesting note that needn't be acted upon.
  ‚îÄProbably a bad idea‚îÄ

  Defaults for ‚Äòdescription‚Äô and ‚Äòcategory‚Äô are set to the same as
  the ‚Äòheading‚Äô. Default for ‚Äòno-todo‚Äô is ‚Äònil‚Äô.

  Scheduled items appear in the agenda; true by default all items are.

  The target is ‚Äòfile+headline‚Äô and the type is ‚Äòentry‚Äô; to see
  other possibilities invoke: C-h o RET org-capture-templates.
  The ‚Äú%?‚Äù indicates the location of the Cursor, in the template,
  when forming the entry.
  "
  `(,shortcut ,description entry
      (file+headline org-default-notes-file
         ,(concat heading "\n#+CATEGORY: " category))
         , (concat "*" (unless no-todo " TODO") " %?\n"
                (when nil ;; this turned out to be a teribble idea.
                  ":PROPERTIES:\n:"
                (if scheduled
                    "SCHEDULED: %^{Any time ‚âà no time! Please schedule this task!}t"
                  "CREATED: %U")
                "\n:END:") "\n\n ")
      :empty-lines 1 :time-prompt t))

;; For now, let's automatically schedule items a week in advance.
;; TODO: FIXME: This overwrites any scheduling I may have performed.
(defun my/org-capture-schedule ()
  (org-schedule nil "+7d"))

(add-hook 'org-capture-before-finalize-hook 'my/org-capture-schedule)

(setq org-capture-templates
  `(
     ,(my/make/org-capture-template "t" "Tasks, Getting Things Done")
     ,(my/make/org-capture-template "r" "Research")
     ,(my/make/org-capture-template "m" "Email")
     ,(my/make/org-capture-template "e" "Emacs (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà")
     ,(my/make/org-capture-template "b" "Blog")
     ,(my/make/org-capture-template "a" "Arbitrary Reading and Learning")
     ,(my/make/org-capture-template "p" "Personal Matters")))
#+end_src

For now I capture everything into a single file.
One would ideally keep separate client, project, information in its own org file.
The ~#+CATEGORY~ appears alongside each task in the agenda view --keep reading.

Looking at ~my/make/org-capture-template~, one notices that capture actually
lets you add /any/ type of item to /any/ file.

Let's also ensure TODO-s respect hierarchical structure.
#+BEGIN_SRC emacs-lisp
;; Cannot mark an item DONE if it has a  TODO child.
;; Conversely, all children must be DONE in-order for a parent to be DONE.
(setq org-enforce-todo-dependencies t)
#+END_SRC

*Where am I currently capturing?*
+ During meetings, when a nifty idea pops into my mind, I quickly capture it.
  - I've found taking my laptop to meetings makes me an active listener
    and I get much more out of my meetings since I'm taking notes.
+ Through out the day, as I browse the web, read, and work; random ideas pop-up, and I capture them indiscriminately.
+ I envision that for a phone call, I would open up a capture to make note of what the call entailed so I can review it later.
+ Anywhere you simply want to make a note, for the current heading, just press
  ~C-c C-z~. The notes are just your remarks along with a timestamp; they are
  collected at the top of the tree, under the heading.

  #+begin_src emacs-lisp
  ;; Ensure notes are stored at the top of a tree.
  (setq org-reverse-note-order nil)
  #+end_src

Anyhow‚Ä¶

Step 1: When new tasks come up
Isn't it great that we can squirrel away info into some default location
then immediately return to what we were doing before --with speed & minimal distraction! ‚ô•‚Äø‚ô•
Indeed, if our system for task management were slow then we may not produce tasks and so forget them altogether! —â(„Çú„É≠„Çú—â)
+ Entering tasks is a desirably impulsive act;
   do not make any further scheduling considerations.

   The next step, the review stage occurring at the end or the start of
   the workday, is for processing.

#+begin_quote
/The reason for this is that entering new tasks should be impulsive, not reasoned.//
/Your reasoning skills are required for the task at hand, not every new tidbit.//
/You may even find that during the few hours that transpire between creating a/
/task and categorizing it, you‚Äôve either already done it or discovered it doesn‚Äôt/
/need to be done at all!/ -- [[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley]]
#+end_quote

When my computer isn't handy, make a note on my phone then transfer it later.

*Step 2: Filing your tasks*
At a later time, a time of reflection, we go to our tasks list and actually schedule time to get them done
by ~C-c C-s~ then pick a date by entering a number in the form ~+n~ to mean that task is due ~n~ days from now.
+ Tasks with no due date are ones that ‚Äúcould happen anytime‚Äù, most likely no time at all.
+ At least schedule tasks reasonably far off in the future, then reassess when the time comes.
+ An uncompleted task is by default rescheduled to the current day, each day, along with how overdue it is.
  - Aim to consciously reschedule such tasks!

  With time, it will become clear what is an unreasonable day
  verses what is an achievable day.

Let's keep track of how many times, and when, we have pushed events to other dates.
#+BEGIN_SRC emacs-lisp
;; Add a note whenever a task's deadline or scheduled date is changed.
(setq org-log-redeadline 'time)
(setq org-log-reschedule 'time)
#+END_SRC


*Step 3: Quickly review the upcoming week*
The next day we begin our work, we press ~C-c a a~ to see the
scheduled tasks for this week --~C-c C-s~ to re-schedule the
task under the cursor and ~r~ to refresh the agenda.
#+begin_src emacs-lisp
(define-key global-map "\C-ca" 'org-agenda)
#+end_src

*Step 4: Getting ready for the day*
After having seen our tasks for the week, we press ~d~ to enter daily view
for the current day. Now we decide whether the items for today are
~A~: of high urgency & important; ~B~: of moderate urgency & importance; or
~C~: Pretty much optional, or very quick or fun to do.
+ ~A~ tasks should be both important /and/ urgently done on the day they were scheduled.
  - Such tasks should be relatively rare!
  - If you have too many, you're anxious about priorities and rendering
    priorities useless.
+ ~C~ tasks can always be scheduled for another day without much worry.
  - Act! If the thought of rescheduling causes you to worry, upgrade it to a
    ~B~ or ~A~.
+ As such, most tasks will generally be priority ~B~:
  Tasks that need to be done, but the exact day isn't as critical as with an
  ~A~ task. These are the ‚Äúbread and butter‚Äù tasks that make up your day to day
  life.

On a task item, press ~,~ then one of ~A, B, C~ to set its priority.
Then ~r~ to refresh.

*Step 5: Doing the work*
Since ~A~ tasks are the important and urgent ones, if you do all of the ~A~ tasks and
nothing else today, no one would suffer. It's a good day (‚îÄ‚Äø‚Äø‚îÄ).

There should be no scheduling nor prioritising at this stage.
You should not be touching your tasks file until your next review session:
Either at the end of the day or the start of the next.

+ Leverage priorities! E.g., When a full day has several ~C~ tasks, reschedule
  them for later in the week without a second thought.
  - You've already provided consideration when assigning priorities.

*Step 6: Moving a task toward completion*
My workflow states are described in the section
[[Workflow States]] and contain states: ~TODO, STARTED, WAITING, ON_HOLD, CANCELLED, DONE~.
+ Tasks marked ~WAITING~ are ones for which we are awaiting some event, like someone
  to reply to our query. As such, these tasks can be rescheduled until I give up
  or the awaited event happens --in which case I go to ~STARTED~ and document
  the reply to my query.
+ The task may be put off indefinitely with ~ON_HOLD~, or I may choose never to do it
  with ~CANCELLED~. Along with ~DONE~, these three mark a task as completed
  and so it needn't appear in any agenda view.

I personally clock-in and clock-out of tasks --keep reading--,
where upon clocking-out I'm prompted for a note about what I've accomplished
so far.
Entering a comment about what I've done, even if it's very little,
feels like I'm getting something done. It's an explicit marker of progress.

In the past, I would make a ‚Äúcaptain's log‚Äù at the end of the day, but that's
like commenting code after it's written, I didn't always feel like doing it and
it wasn't that important after the fact. The continuous approach of noting after
every clock-out is much more practical, for me at least.

*Step 7: Archiving Tasks*
During the review state,
when a task is completed, ‚Äòarchive‚Äô it with ~C-c C-x C-s~: This marks it as done, adds a time stamp,
and moves it to a local ~*.org_archive~ file. This was our ‚Äòto do‚Äô list becomes a ‚Äòta da‚Äô list showcasing
all we have done (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

Archiving keeps task lists clutter free, but unlike deletion it allows
us, possibly rarely, to look up details of a task or what tasks were completed
in a certain time frame --which may be a motivational act, to see that you have
actually completed more than you thought, provided you make and archive tasks
regularly. We can use ~(org-search-view)~ to search an org file /and/ the
archive file too, if we enable it so.
#+BEGIN_SRC emacs-lisp
;; C-c a s ‚û© Search feature also looks into archived files.
;; Helpful when need to dig stuff up from the past.
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+END_SRC

#+begin_src emacs-lisp
;; Invoing the agenda command shows the agenda and enables
;; the org-agenda variables.
(org-agenda "a" "a")
#+end_src

Let's install some helpful views for our agenda.
+ ~C-c a c~: See completed tasks at the end of the day and archive them.
  #+begin_src emacs-lisp
;; Pressing ‚Äòc‚Äô in the org-agenda view shows all completed tasks,
;; which should be archived.
(add-to-list 'org-agenda-custom-commands
  '("c" todo "DONE|ON_HOLD|CANCELLED" nil))
#+end_src
+ ~C-c a u~: See unscheduled, undeadlined, and undated tasks in my todo files.
  Which should then be scheduled or archived.
  #+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
  '("u" alltodo ""
     ((org-agenda-skip-function
        (lambda ()
              (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp  "\n]+>")))
              (org-agenda-overriding-header "Unscheduled TODO entries: "))))
#+end_src

# Org-protocol is a great way to create capture notes in org-mode from other applications.
** Super Agenda
The following incentivizes us to make use of ~:tags:~ so that our agenda displays
the tasks of the day depending on their tags ---possibly using complex predicates.
This is far preferable to having them all in one big list.
#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda)
(org-super-agenda-mode)

(setq org-super-agenda-groups
      ;; Default order is 0, first come first serve.
      ;; Items are ‚Äúor‚Äù-ed by default.
      '((:name "Important"
               :tag "PackageFormer"
               :and (:tag "JC" :priority "A")
               :and (:tag "WK" :priority "A")
               :priority "A")

        ;; Groups supply their own section names when none are given
        (:tag "personal")
        (:tag "3mi3")
        (:name "Emacs Init" :tag "init")
        (:priority<= "B" :order 1)
        )))
#+END_SRC

The [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] homepage shows complex configurations and pleasant screenshots
contrasting with and without the system.

** Automating [[https://en.wikipedia.org/wiki/Pomodoro_Technique][Pomodoro]] --Dealing with dreadful tasks
:PROPERTIES:
:CUSTOM_ID: Automating-[[https://en.wikipedia.org/wiki/Pomodoro_Technique][Pomodoro]]---Dealing-with-dreadful-tasks
:END:

Effort estimates are for an entire task.
Yet, sometimes it's hard to even get started on some tasks.

+ The code below ensures a 25 minute timer is started whenever clocking in happens.

    - The timer is in the lower right of the modeline.

+ When the timer runs out, we get a notification.

+ We may have the momentum to continue on the dreadful task, or clock-out and take a break after
  documenting what was accomplished.

#+BEGIN_SRC emacs-lisp
;; Tasks get a 25 minute count down timer
(setq org-timer-default-timer 25)

;; Use the timer we set when clocking in happens.
(add-hook 'org-clock-in-hook
  (lambda () (org-timer-set-timer '(16))))

;; unless we clocked-out with less than a minute left,
;; show disappointment message.
(add-hook 'org-clock-out-hook
  (lambda ()
  (unless (s-prefix? "0:00" (org-timer-value-string))
     (message-box "The basic 25 minutes on this dreadful task are not up; it's a shame to see you leave."))
     (org-timer-stop)
     ))
#+END_SRC

Note that this does not conflict with the total effort estimate for the task.

** Journaling
:PROPERTIES:
:CUSTOM_ID: Journaling
:END:

Thus far I've made it easy to quickly capture ideas and tasks,
not so much on the analysis phase:

- What was accomplished today?
- What are some notably bad habits? Good habits?
- What are some future steps?

Rather than overloading the capture mechanism for such thoughts,
let's employ ~org-journal~ --journal entries are stored in files such as
~journal/20190407~, where the file name is simply the date, or only one
file per year as I've set it up below.
Each entry is the week day, along with the date,
then each child tree is an actual entry with a personal
title preceded by the time the entry was made.
Unlike capture and its agenda support, journal ensures entries are maintained in
chronological order with calendar support.

Since org files are plain text files, an entry can
be written anywhere and later ported to the journal.

The separation of concerns is to emphasise the capture stage
as being quick and relatively mindless, whereas the Journaling
stage as being mindful.
Even though we may utilise capture to provide quick support for including
journal entries, I have set my journal to be on a yearly basis --one file per year--
since I want to be able to look at previous entries when making the current entry;
after all, it's hard to compare and contrast easily unless there's multiple entries
opened already.

As such, ideally at the end of the day, I can review what
has happened, and what has not, and why this is the case,
and what I intend to do about it, and what problems were encountered
and how they were solved --in case the problem is encountered again in the future.
*Consequently, if I encounter previously confronted situations, problems,*
*all I have to do is reread my journal to get an idea of how to progress.*
Read more about [[https://www.google.com/search?q=on+the+importance+of+reviwing+your+day+daily&oq=on+the+importance+of+reviwing+your+day+daily&aqs=chrome..69i57.367j0j7&sourceid=chrome&ie=UTF-8][the importance of reviewing your day on a daily basis]].

Moreover, by journaling with Org on a daily basis, it can be
relatively easy to produce a report on what has been happening
recently, at work for example. For now, there is no need to
have multiple journals, for work and for personal life, as
such I will utilise the tag ~:work:~ for non-personal matters.

Anyhow, the setup:
#+begin_src emacs-lisp
(use-package org-journal
  ; :bind (("C-c j" . org-journal-new-entry))
  :config
  (setq org-journal-dir "~/Dropbox/journal/"
        org-journal-file-type 'yearly
        org-journal-file-format "Personal-%Y-%m-%d")
)

(defun my/org-journal-new-entry (prefix)
  " Open today‚Äôs journal file and start a new entry.

    With a prefix, we use the work journal; otherwise the personal journal.
  "
  (interactive "P")
  (if prefix
      (let ((org-journal-file-format "Work-%Y-%m-%d"))
        (org-journal-new-entry nil))
    (org-journal-new-entry nil))
  (org-mode) (org-show-all))

;; C-u C-c j ‚áí Work journal ;; C-c C-j ‚áí Personal journal
(global-set-key (kbd "C-c j") 'my/org-journal-new-entry)
#+end_src

Bindings available in ~org-journal-mode~, when journaling:
+ ~C-c C-j~: Insert a new entry into the current journal file.
   - Note keys for ~org-journal-new-entry~ overwrite those for ~org-goto~.
+ ~C-c C-s~: Search the journal for a string.
  - Note keys for ~org-journal-search~ overwrite those for ~org-schedule~.

# C-c C-f - go to the next journal file.
# C-c C-b - go to the previous journal file.

All journal entries are registered in the Emacs Calendar.
To see available journal entries do ~M-x calendar~.
Bindings available in the calendar-mode:

+ ~j~: View an entry in a new buffer.
     # C-j - view an entry but do not switch to it.
+ ~i j~: add a new entry into the day‚Äôs file
+ ~f w/m/y/f/F~: Search in all entries of the current week, month, year, all of time,
  of in all entries in the future.
#
# [ - go to previous day with journal entries.
# ] - go to next day with journal entries.

# Some key-bindings in org-journal overwrite org-mode key bindings
# Major modes are supposed to only use key bindings of the form C-c C-?, where ? can be any letter. With org-mode already using most interesting keys, collisions are inevitable. Currently, org-journal overwrites
#
# C-c C-f (org-forward-heading-same-level) with org-journal-open-next-entry
# C-c C-b (org-backward-heading-same-level) with org-journal-open-previous-entry

** Workflow States
:PROPERTIES:
:CUSTOM_ID: WorkflowStates
:END:

Here are some of my common workflow states, ---the ‚ÄòX/Y‚Äô indicates to do action ‚ÄòX‚Äô
when entering a state and ‚ÄòY‚Äô when leaving it, with ‚Äò!‚Äô denoting a timestamp
should be generated and ‚Äò@‚Äô denoting a user note should be made.
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "STARTED(s@/!)" "|" "DONE(d/!)")
              (sequence "WAITING(w@/!)" "ON_HOLD(h@/!)" "|" "CANCELLED(c@/!)"))))

;; Since DONE is a terminal state, it has no exit-action.
;; Let's explicitly indicate time should be noted.
(setq org-log-done 'time)
#+end_src

The ~@~ brings up a pop-up to make a local note about why the state changed.
*Super cool stuff!*
In particular, we transition from ~TODO~ to ~STARTED~ once 15 minutes, or a
reasonable amount, of work has transpired.
Since all but one state are marked for logging, we could use the
~lognotestate~ logging facility of org-mode, which prompts for a note
every time a task‚Äôs state is changed.

Entering a comment about what I've done, even if it's very little,
feels like I'm getting something done. It's an explicit marker of progress
and motivates me to want to change my task's states more often until I see
it marked ~DONE~.

Here's how they are coloured,
#+begin_src emacs-lisp
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("STARTED" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("ON_HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold))))
#+end_src

Now we press ~C-c C-t~ then the letter shortcut to actually make the state of an org heading.
#+begin_src emacs-lisp
(setq org-use-fast-todo-selection t)
#+end_src

We can also change through states using Shift- left, or right.
# (setq org-treat-S-cursor-todo-selection-as-state-change nil)

Let's draw a state diagram to show what such a workflow looks like.

[[http://plantuml.com/index][PlantUML]] supports drawing diagrams in a tremendously simple format
--it even supports Graphviz/DOT directly and many other formats.
Super simple setup instructions can be found [[http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html][here]]; below are a bit more
involved instructions. Read the manual [[http://plantuml.com/guide][here]].

#+begin_src emacs-lisp
;; Install the tool
; (async-shell-command "brew cask install java") ;; Dependency
; (async-shell-command "brew install plantuml")

;; Tell emacs where it is.
;; E.g., (async-shell-command "find / -name plantuml.jar")
(setq org-plantuml-jar-path
      (expand-file-name "/usr/local/Cellar/plantuml/1.2019.5/libexec/plantuml.jar"))

;; Enable C-c C-c to generate diagrams from plantuml src blocks.
(add-to-list 'org-babel-load-languages '(plantuml . t) )
(require 'ob-plantuml)

; Use fundamental mode when editing plantuml blocks with C-c '
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
#+end_src

# (async-shell-command "cp workflow.png ~/alhassy.github.io/assets/img/")

Let's use this!
# The source block is replaced with the generated image in-place, by default.
# #+begin_src plantuml :file workflow.png :exports code :cache (progn (async-shell-command "cp workflow.png ~/alhassy.github.io/assets/img/") "yes")
#+begin_src plantuml :file workflow.png :exports code :cache "yes" :tangle no
skinparam defaultTextAlignment center  /' Text alignment '/

skinparam titleBorderRoundCorner 15
skinparam titleBorderThickness 2
skinparam titleBorderColor red
skinparam titleBackgroundColor Aqua-CadetBlue
title My Personal Task States

[*] -> Todo  /' This is my starting state '/
Done -right-> [*]  /' This is an end state '/
Cancelled -up-> [*]  /' This is an end state '/

/'A task is ‚ÄúTodo‚Äù, then it's ‚Äústarted‚Äù, then finally it's ‚Äúdone‚Äù. '/
Todo    -right-> Started
Started -down->  Waiting
Waiting -up->    Started
Started -right-> Done

/'Along the way, I may put pause the task for some reason then
  return to it. This may be since I'm ‚ÄúBlocked‚Äù since I need
  something, or the task has been put on ‚Äúhold‚Äù since it may not
  be important right now, and it may be ‚Äúcancelled‚Äù eventually.
'/

Todo    -down-> Waiting
Waiting -up-> Todo
Waiting -up-> Done

Todo -down-> On_Hold
On_Hold -> Todo

On_Hold -down-> Cancelled
Waiting -down-> Cancelled
Todo    -down-> Cancelled

/' The Org-mode shortcuts for these states are as follows. '/
Todo      : t
On_Hold   : h
Started   : s
Waiting   : w
Cancelled : c
Done      : d

/' If a task is paused, we should document why this is the case. '/
note right of Waiting: Note what is\nblocking us.
note right of Cancelled: Note reason\nfor cancellation.
note bottom of On_Hold: Note reason\nfor reduced priority.

center footer  ‚ô•‚Äø‚ô• Org-mode is so cool (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
/' Note that we could omit the ‚Äúcenter, left, right‚Äù if we wished,
   or used a ‚Äúheader‚Äù instead.'/
#+end_src

#+RESULTS[b18d24821fb7ae373e8a7efe4b0c3a27d0469837]:
[[file:normal_task_states.png]]

# (org-display-inline-images t t)
# (shell-command "rm workflow.png")
#+HTML: <img src="../assets/img/workflow.png" alt="My Personal Task States">

Of note:
+ Multiline comments are with ~/' comment here '/~, single quote starts a one-line comment.
+ Nodes don't need to be declared, and their names may contain spaces if they are enclosed in double-quotes.
+ One forms an arrow between two nodes by writing a line with ~x ->[label here] y~
  or ~y <- x~; or using ~-->~ and ~<--~ for dashed lines. The label is optional.

  To enforce a particular layout, use ~-X->~ where ~X ‚àà {up, down, right, left}~.

+ To declare that a node ~x~ has fields ~d, f~ we make two new lines having
  ~x : f~ and ~x : d~.
+ One adds a note by a node ~x~ as follows: ~note right of x: words then newline\nthen more words~.
  Likewise for notes on the ~left, top, bottom~.
  # - A note can be on several lines. It's terminated by ~end note~.
 + Interesting sprites and many other things can be done with PlantUML. Read the docs.

This particular workflow is inspired by [[http://doc.norang.ca/org-mode.html][Bernt Hansen]]
--while quickly searching through the PlantUML [[http://plantuml.com/guide][manual]]:
The above is known as an ‚Äúactivity diagram‚Äù and it's covered in ¬ß4.

** Org-Emphasise for Parts of Words :Disabled:
:PROPERTIES:
:CUSTOM_ID: Org-Emphasise-for-Parts-of-Words
:END:

From [[https://stackoverflow.com/a/24540651/3550444][stackoverflow]], the following incantation allows us to have
parts of works emphasied with org-mode; e.g.,
/half/ed, ~half~ed, and right in the m*idd*le! Super cool stuff!
#+BEGIN_SRC emacs-lisp :tangle no
(setcar org-emphasis-regexp-components " \t('\"{[:alpha:]")
(setcar (nthcdr 1 org-emphasis-regexp-components) "[:alpha:]- \t.,:!?;'\")}\\")
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

I've disabled this feature since multiple occurrences
of an emphasise marker are sometimes treated as one
lengthy phrase being emphasised.

** TODO COMMENT Making Block Delimiters Less Intrusive :noexport:prettify_symbols_not_loading:
:PROPERTIES:
:CUSTOM_ID: COMMENT-Making-Block-Delimiters-Less-Intrusive
:END:

Let us render Org-mode's
~#+begin_src~
and
~#+end_src~
less obtrusively by, e.g., having the former render as a pencil marker ‚úé
and the latter as a tombstone ‚ñ° ---reminiscent of Halmos' QED end-of-proof marker.
His setup also accounts for quotes.

‚ü™ Incantation Omitted ---Visit [[https://pank.eu/blog/pretty-babel-src-blocks.html#coderef-symbol][Rasmus Roulund]]'s site & copy-paste it, if you wish ‚ü´
:Hide:
#+begin_src emacs-lisp
  (defvar-local rasmus/org-at-src-begin -1
    "Variable that holds whether last position was a ")

  (defvar rasmus/ob-header-symbol ?‚ò∞
    "Symbol used for babel headers")

  (defun rasmus/org-prettify-src--update ()
    (let ((case-fold-search t)
          (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
          found)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward re nil t)
          (goto-char (match-end 0))
          (let ((args (org-trim
                       (buffer-substring-no-properties (point)
                                                       (line-end-position)))))
            (when (org-string-nw-p args)
              (let ((new-cell (cons args rasmus/ob-header-symbol)))
                (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                (cl-pushnew new-cell found :test #'equal)))))
        (setq prettify-symbols-alist
              (cl-set-difference prettify-symbols-alist
                                 (cl-set-difference
                                  (cl-remove-if-not
                                   (lambda (elm)
                                     (eq (cdr elm) rasmus/ob-header-symbol))
                                   prettify-symbols-alist)
                                  found :test #'equal)))
        ;; Clean up old font-lock-keywords.
        (font-lock-remove-keywords nil prettify-symbols--keywords)
        (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
        (font-lock-add-keywords nil prettify-symbols--keywords)
        (while (re-search-forward re nil t)
          (font-lock-flush (line-beginning-position) (line-end-position))))))

  (defun rasmus/org-prettify-src ()
    "Hide src options via `prettify-symbols-mode'.

  `prettify-symbols-mode' is used because it has uncollpasing. It's
  may not be efficient."
    (let* ((case-fold-search t)
           (at-src-block (save-excursion
                           (beginning-of-line)
                           (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
      ;; Test if we moved out of a block.
      (when (or (and rasmus/org-at-src-begin
                     (not at-src-block))
                ;; File was just opened.
                (eq rasmus/org-at-src-begin -1))
        (rasmus/org-prettify-src--update))
      ;; Remove composition if at line; doesn't work properly.
      ;; (when at-src-block
      ;;   (with-silent-modifications
      ;;     (remove-text-properties (match-end 0)
      ;;                             (1+ (line-end-position))
      ;;                             '(composition))))
      (setq rasmus/org-at-src-begin at-src-block)))

  (defun rasmus/org-prettify-symbols ()
    (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
          (cl-reduce 'append
                     (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                             `(("#+begin_src" . ?‚úé) ;; ‚û§ üñù ‚ûü ‚û§ ‚úé
                               ("#+end_src"   . ?‚ñ°) ;; ‚èπ
                               ("#+header:" . ,rasmus/ob-header-symbol)
                               ("#+begin_quote" . ?¬ª)
                               ("#+end_quote" . ?¬´)))))
    (turn-on-prettify-symbols-mode)
    (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
  (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols)

;; Last up¬≠dated: 2019-06-09
#+end_src

:End:

# (rasmus/org-prettify-src--update)
#+BEGIN_SRC emacs-lisp
"noice"
#+END_SRC

His development relies on built-in prettify-symbols-mode, which disguises strings in a
buffer for the sake of readability or aesthetics.
Following the example in the documentation, ~C-h f prettify-symbols-mode~,
we can quickly approximate his efforts for ~example~ blocks as follows, however a main issue
is that source blocks have busybodied headers which his setup disguises as ‚Äò‚â°‚Äô.
#+begin_src emacs-lisp :tangle yes
(global-prettify-symbols-mode)

(defvar my-prettify-alist nil
  "Musa's personal prettifications.")

(push '("<=" . ?‚â§) my-prettify-alist)
(push '("->" . ?‚Üí) my-prettify-alist)
(push '("-->" . ?‚ü∂) my-prettify-alist)
(push '("#+begin_example" . (?‚Ñ∞ (Br . Bl) ?‚áí)) my-prettify-alist) ;; ‚Ñ∞‚áí
(push '("#+end_example" . ?‚áê) my-prettify-alist)                  ;; ‚áê
(push '("{{{fold(" . ?‚Ü≥) my-prettify-alist)
(push '(")}}}" . ?‚Ü≤) my-prettify-alist)
(push '("{{{end-fold}}}" . ?‚Ü∫) my-prettify-alist)

(when (<= 1 2)) ;; prettify symbols not loading

(-let [modify (lambda ()
              (setq prettify-symbols-alist
                    (append my-prettify-alist prettify-symbols-alist)))]

  (add-hook 'text-mode-hook modify)
  (add-hook 'prog-mode-hook modify)
  ;; For org-example blocks, ‚ÄúC-c '‚Äù to see the prettifications of language constructs.
  ;; Or alter the particular hook directly.
  (add-hook 'org-mode-hook modify) ;; for the folding blocks
)
#+end_src

See [[http://www.modernemacs.com/post/prettify-mode/][‚ÄúMathematical Notation in Emacs‚Äù]] for how such prettifications can make verbose (Python)
scripts much more readable by employing more economical disguises.

A nice sanity:
#+BEGIN_SRC emacs-lisp
;; Un-disguise a symbol when cursour is inside it or at the right-edge of it.
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

The ~‚Ü≥Title Here‚Ü≤ Contents ‚Ü∫~ combination is for my makeshift HTML code folding macro
---word-wrapped for readability.
#+BEGIN_SRC org :tangle no
,#+MACRO: end-fold  #+HTML: </details>
,#+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong>
                              <font face="Courier" size="3" color="green"> $1
                              </font> </strong> </summary>
#+END_SRC

Let's have this fold-away in the source buffer as well by using [[https://www.emacswiki.org/emacs/FoldingMode][folding-mode]];
with show/hide with ~C-<tab>~ key.
#+BEGIN_SRC emacs-lisp
(use-package folding
 :init
 (folding-add-to-marks-list 'org-mode               "{{{fold(" "{{{end-fold}}}" nil t)
 ; (setq folding-top-mark "{{{fold(")
 ; (setq folding-bottom-mark "{{{end-fold}}}")
 :config
  (define-key folding-mode-map (kbd "C-<tab>")       #'folding-toggle-show-hide)
  (add-hook 'org-mode-hook #'folding-mode)
)
#+END_SRC

#+RESULTS:
: t

:Example:

# The (org-mode-restart) invocation actually enables the source block prettifications.

# Empty macros to make the example go through.
#
#+MACRO: end-fold
#+MACRO: fold


{{{fold(nice)}}}

hello

{{{end-fold}}}

:End:

** Working with Citations
:PROPERTIES:
:CUSTOM_ID: Working-with-Citations
:END:
 [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

 The following entity will display useful data
 when the mouse hovers over it (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà If you click on it, then you're
 in for a lot of super neat stuff, such as searching for the pdf online!

 cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no ‚Äú‚ï≤bibliography{‚ãØ}‚Äù is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("~/thesis-proposal/References.bib"))

(use-package helm-bibtex :demand t)

(setq bibtex-completion-bibliography "~/thesis-proposal/References.bib")
#+END_SRC
#
#  \bibliography{~/thesis-proposal/References.bib}

  Execute ~M-x helm-bibtex~ or ~C-c ] and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‚Äòagda‚Äô. Super cool stuff.

  Read the manual [[https://github.com/jkitchin/org-ref/blob/master/org-ref.org][online]] or better yet as an org-file with ~M-x org-ref-help~.

** Show off-screen Heading at the top of the window
:PROPERTIES:
:CUSTOM_ID: Show-off-screen-Heading-at-the-top-of-the-window
:END:

In case we forgot which heading we're under, let's keep
the current heading stuck at the top of the window.
#+BEGIN_SRC emacs-lisp
 (use-package org-sticky-header
  :config
  (setq-default
   org-sticky-header-full-path 'full
   ;; Child and parent headings are seperated by a /.
   org-sticky-header-outline-path-separator " / "))

(add-hook 'org-mode-hook #'org-sticky-header-mode)
#+END_SRC

** Clocking Work Time
:PROPERTIES:
:CUSTOM_ID: Clocking-Work-Time
:END:

Let's keep track of the time we spend working on tasks that we may have captured for ourselves the previous day.
Such statistics provides a good idea of how long it actually takes me to accomplish a certain task in the future
and it lets me know where my time has gone.

+ Clock in :: on a heading with ~I~, or in the subtree with ~C-c C-x C-i~.
+ Clock out :: of a heading with ~O~, or in the subtree with ~C-c C-x C-o~.
+ Clock report :: See clocked times with ~C-c C-x C-r~.

After clocking out, the start and end times, as well as the elapsed time, are added to a drawer
to the heading. We can punch in and out of tasks as many times as desired, say we took a break or
switched to another task, and they will all be recorded into the drawer.

#+begin_src emacs-lisp
;; Record a note on what was accomplished when clocking out of an item.
(setq org-log-note-clock-out t)
#+end_src

To get started, we could estimate how long a task will take and clock-in;
then clock-out and see how long it actually took.

# To review the day‚Äôs accomplishments, type ‚Äòl‚Äô
# (org-agenda-log-mode) from the agenda view.

Moreover, we can overlay due dates and priorities to tasks in a non-intrusive way that is
easy to edit by hand.

#+begin_src emacs-lisp
;; List of all the files & directories where todo items can be found. Only one for now.
(setq org-agenda-files '("~/Dropbox/todo.org"))

;; How many days ahead the default agenda view should look
(setq org-agenda-ndays 7)

;; How many days early a deadline item will begin showing up in your agenda list.
(setq org-deadline-warning-days 14)

;; In the agenda view, days that have no associated tasks will still have a line showing the date.
(setq org-agenda-show-all-dates t)

(setq org-agenda-skip-deadline-if-done t)

;; Scheduled items marked as complete will not show up in your agenda view.
(setq org-agenda-skip-scheduled-if-done t)

;; The agenda view ‚Äì even in the 7-days-at-a-time view ‚Äì will always begin on the current day.
;; This is important, since while using org-mode as a day planner, you never want to think of
;; days gone past. That‚Äôs something you do in other ways, such as when reviewing completed tasks.
(setq org-agenda-start-on-weekday nil)
#+end_src

Sometimes, at the beginning at least, I would accidentally invoke the transposed
command ~C-x C-c~, which saves all buffers and quits Emacs. So here's a helpful
way to ensure I don't quit Emacs accidentally.
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

#+begin_src emacs-lisp
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)

;; Show lot of clocking history
(setq org-clock-history-length 23)

;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)

;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)

;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)

;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)

;; Do not prompt to resume an active clock
;; (setq org-clock-persist-query-resume nil)

;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
#+end_src

*Finding tasks to clock in*
Use one of the following options, with the top-most being the first to be tried.
+ From anywhere, ~C-u C-c C-x C-i~ yields a pop-up for recently clocked in tasks.
+ Pick something off today's agenda scheduled items.
+ Pick a ~Started~ task from the agenda view, work on this unfinished task.
+ Pick something from the ~TODO~ tasks list in the agenda view.

# Reporting activities
# C-c C-x i

+ ~C-c C-x C-d~ also provides a quick summary of clocked time for the current org file.

*Estimates versus actual time*
Before clocking into a task, add to the properties drawer ~:Effort: 1:25~ or ~C-c C-x C-e~, for a task
that you estimate will take an hour an twenty-five minutes, for example. Now the modeline
will have will mention the time elapsed alongside the task name.
+ This is also useful when you simply want to put a time limit on a task that wont be
  completed anytime soon, say writing a thesis or a long article, but you still want
  to work on it for an hour a day and be warned when you exceed such a time constraint.

  :Not_working_for_me:
  Even if you switch tasks then clock into this task again, the alarm will ring
  again, nagging you to actual listen to yourself and work on other matters.

  #+begin_src emacs-lisp
(setq org-clock-sound "~/.emacs.d/school-bell.wav")
#+end_src
   :end:

  When you've gone above your estimate time, the modeline shows it to be red.

** COMMENT ‚ü®replaced with yankpand, below‚ü© Template expansion (<s Tab, etc.)
:PROPERTIES:
:CUSTOM_ID: COMMENT-‚ü®replaced-with-yankpand,-below‚ü©-Template-expansion-(<s-Tab,-etc.)
:END:
In org-mode we type ~<X TAB~ to obtain environment templates, such as ~<s~ for source blocks
or ~<q~ for quote blocks.
It seems recent [[https://orgmode.org/Changes.html#org1b5e967][changes]] to the org-mode structure template expansion
necessitate explicitly loading ~org-tempo~.
#+begin_src emacs-lisp
;; (require 'org-tempo)
;; (use-package org-contrib)
#+end_src

To insert source blocks with the assistance of a pop-up: ~C-c C-v d~ ;-)
Perhaps more usefully, invokcaing within a source block splits it up into two
seperate blocks! Moreover, if invoked on a selected region, it puts the region
into a new code block! Wow!

+ ~<X~ allows you to obtain the org-block assigned to shortcut ~x~.
+ ~C-C C-v C-d~ and ~C-c C-v d~ refer to the ~org-babel-demarcate-block~, which
  provides /source/ blocks.
+ ~C-c C-,~ refers to ~org-insert-structure-template~, which
  provides non-source blocks, such as quote ~<q~ and comment ~C~.

*** ~<el~ Emacs-lisp source blocks
:PROPERTIES:
:CUSTOM_ID: ~<el~-Emacs-lisp-source-blocks
:END:

~<el~ to begin an emacs-lisp source block -- ~<e~ is for an example block.
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
     '("el" . "src emacs-lisp"))

(require 'org-tempo)
;; (defun org--check-org-structure-template-alist (x) "n" t)
#+END_SRC


*** COMMENT TODO Demoing Dot Graphs
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-Demoing-Dot-Graphs
:END:
We include one to demo the capabilities of the previous subsection.

#+BEGIN_SRC emacs-lisp
;; Graphviz: Press <g-TAB to obtain a minimal editable example.
(add-to-list 'org-structure-template-alist
        '("g" "#+begin_src dot :results output graphics :file \"/tmp/graph.pdf\" :exports both
   digraph G {
      node [color=black,fillcolor=white,shape=rectangle,style=filled,fontname=\"Helvetica\"];
      A[label=\"A\"]
      B[label=\"B\"]
      A->B
   }\n#+end_src" "<src lang=\"dot\">\n\n</src>"))
#+END_SRC

Here's another example graph,
#+BEGIN_EXAMPLE org
 #+BEGIN_SRC dot :file simple_markov.png :cmdline -Kdot -Tpng
 graph {
   rankdir="UD";
    A -- D;
    A -- B;
    D -- C;
    B -- C;
  }
 #+END_SRC
#+END_EXAMPLE

*** COMMENT Parallel
:PROPERTIES:
:CUSTOM_ID: COMMENT-Parallel
:END:

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist '("p" . "parallel latex"))
#+END_SRC

** [[https://revealjs.com/?transition=zoom#/][Reveal.JS]] -- The HTML Presentation Framework
:PROPERTIES:
:CUSTOM_ID: [[https://revealjs.com/?transition=zoom#/][Reveal.JS]]----The-HTML-Presentation-Framework
:END:

Org-mode documents can be transformed into beautiful slide decks
with [[https://github.com/yjwen/org-reveal/blob/master/Readme.org][org-reveal]] with the following two simple lines.

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
 :config (setq org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+END_SRC

For example, execute --~C-c C-c~--  the following block to see an example slide-deck (‚îÄ‚Äø‚Äø‚îÄ)
#+BEGIN_SRC emacs-lisp :tangle no
(shell-command "curl https://raw.githubusercontent.com/yjwen/org-reveal/master/Readme.org >> Trying_out_reveal.org")
(with-temp-buffer (find-file "Trying_out_reveal.org")
 (org-reveal-export-to-html-and-browse)
)
#+END_SRC

Org-mode exporting --~C-c C-e~-- now includes an option ~R~ for such reveal slide decks.

** Coloured LaTeX using Minted
:PROPERTIES:
:CUSTOM_ID: Coloured-LaTeX-using-Minted
:END:
Execute the following for bib ref as well as minted
Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
--which in turn requires the pygmentize system tool.
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -output-directory %o %f"
        "biber %b"
        "pdflatex -shell-escape -output-directory %o %f"
        "pdflatex -shell-escape -output-directory %o %f")
)
#+END_SRC

For faster pdf generation, possibly with errors, consider invoking:
#+begin_example emacs-lisp
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"))
#+end_example

By default, Org exports LaTeX using the ~nonstopmode~ option, which tries
its best to produce a PDF ---which ignores typesetting errors altogether,
which is not necessary ideal when using LaTeX.

** Executing code from ~src~ blocks
:PROPERTIES:
:CUSTOM_ID: Executing-code-from-~src~-blocks
:END:

For example, to execute a shell command in emacs,
write a ~src~ with a shell command, then ~C-c c-c~ to see the results.
Emacs will generally query you to ensure you're sure about executing the
(possibly dangerous) code block; let's stop that:
#+BEGIN_SRC emacs-lisp
; Seamless use of babel: No confirmation upon execution.
;; Downside: Could accidentally evaluate harmful code.
(setq org-confirm-babel-evaluate nil)
#+END_SRC

A worked out example can be obtained as follows: ~<g TAB~ then ~C-c C-C~ to make a nice
simple graph --the code for this is in the next section.

Some initial languages we want org-babel to support:
#+BEGIN_SRC emacs-lisp
 (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (emacs-lisp . t)
     ;; (shell	 . t)
     (python . t)
     (haskell . t)
     (ruby	 . t)
     (ocaml	 . t)
     (C . t)  ;; Captial ‚ÄúC‚Äù gives access to C, C++, D
     (dot	 . t)
     (latex	 . t)
     (org	 . t)
     (makefile	 . t)
     ))

;; Preserve my indentation for source code during export.
(setq org-src-preserve-indentation t)

;; The export process hangs Emacs, let's avoid this.
;; MA: For one reason or another, this crashes more than I'd like.
;; (setq org-export-in-background t)
#+END_SRC

More languages can be added using ~add-to-list~.

** ~ox-extra~: Using ~:ignore:~ to ignore headings but use the bodies
:PROPERTIES:
:CUSTOM_ID: ~ox-extra~:-Using-~:ignore:~-to-ignore-headings-but-use-the-bodies
:END:

** COMMENT org-mode header generation
:PROPERTIES:
:CUSTOM_ID: COMMENT-org-mode-header-generation
:END:
Generate an untitled org-mode skeleton file ~C-x t~ --similar to ~C-x C-f~ for finding files.

First the template,
# For some reason if I use "org" as source language my variable "thedate"
# is not utilised, hence I'm using emacs-lisp as language.
#
#+NAME: org template
#+BEGIN_SRC latex :var thedate=(format-time-string "%a %Y-%m-%d") :tangle template.org :exports code
,#+TITLE: ???
,#+DATE: thedate
,#+DESCRIPTION: A new radical entry of things I'm learning!
,#+AUTHOR: Musa Al-hassy
,#+EMAIL: alhassy@gmail.com
,#+IMAGE: ../assets/img/rwh-200.jpg
,#+CATEGORIES: ExampleTags Elisp Haskell Frama-C Specfications Krakatoa
,#+OPTIONS: toc:nil html-postamble:nil
,# Other possible are num:nil todo:nil pri:nil tags:nil ^:nil
,#+STARTUP: indent

,* Abstract       :ignore:
,#+BEGIN_CENTER
*Abstract*

This article serves to accomplish *???*.
Write your goal then attempt to realise it, otherwise there's no explicit direction!

,#+END_CENTER

,* Introduction

Let's recall concepts ~X~ needed to discuss notions $Y$.

,* Middle

We're learnin'!

,* Conclusion

Yeah! That was some fun stuff!

,* COMMENT footer

# Local Variables:
# eval: (setq NAME (file-name-sans-extension (buffer-name)))
# eval: (load-file "AlBasmala.el")
# End:
#+END_SRC

Then the functionality,
#+BEGIN_SRC emacs-lisp
(defun new-untitled-org-template ()
  "Produce an org-mode file template."
  (interactive)
  (switch-to-buffer (generate-new-buffer "*Untitled*"))
  (insert (file-as-string "~/.emacs.d/template.org"))
  (org-mode)
)

(global-set-key (kbd "C-x t") 'new-untitled-org-template)
#+END_SRC

** Hiding Emphasise Markers & Inlining Images
:PROPERTIES:
:CUSTOM_ID: Hiding-Emphasise-Markers-&-Inlining-Images
:END:
#+BEGIN_SRC emacs-lisp
;; org-mode math is now highlighted ;-)
(setq org-highlight-latex-and-related '(latex))

;; Hide the *,=,/ markers
(setq org-hide-emphasis-markers t)

;; (setq org-pretty-entities t)
;; to have \alpha, \to and others display as utf8 http://orgmode.org/manual/Special-symbols.html
#+END_SRC

The following is now disabled --it makes my system slower than I'd like.
#+BEGIN_SRC emacs-lisp :tangle no
;; Let's set inline images.
(setq org-display-inline-images t)
(setq org-redisplay-inline-images t)
(setq org-startup-with-inline-images "inlineimages")

;; Automatically convert LaTeX fragments to inline images.
(setq org-startup-with-latex-preview t)
#+END_SRC

:yay_it_worked:

$e^x = \sum_{n = 0}^\infty \frac{x^n}{n!}$

~awkward~ or $not$

:end:

** Jumping without hassle
:PROPERTIES:
:CUSTOM_ID: Jumping-without-hassle
:END:

#+BEGIN_SRC emacs-lisp
(defun my/org-goto-line (line)
  "Go to the indicated line, unfolding the parent Org header.

   Implementation: Go to the line, then look at the 1st previous
   org header, now we can unfold it whence we do so, then we go
   back to the line we want to be at.
  "
  (interactive "nEnter line: ")
  (goto-line line)
  (org-previous-visible-heading 1)
  (org-cycle)
  (goto-line line)
)
#+END_SRC

** Folding within a subtree
:PROPERTIES:
:CUSTOM_ID: Folding-within-a-subtree
:END:

#+BEGIN_SRC emacs-lisp
(defun my/org-fold-current-subtree-anywhere-in-it ()
  "Hide the current heading, while being anywhere inside it."
  (interactive)
  (save-excursion
    (org-narrow-to-subtree)
    (org-shifttab)
    (widen))
)

(add-hook 'org-mode-hook '(lambda ()
  (local-set-key (kbd "C-c C-h") 'my/org-fold-current-subtree-anywhere-in-it)))
#+END_SRC

** Ensuring Useful HTML Anchors
:PROPERTIES:
:CUSTOM_ID: Ensuring-Useful-HTML-Anchors
:END:
Upon HTML export, each tree heading is assigned an ID to be used for hyperlinks.
Default IDs are something like ~org1957a9d~, which does not endure the test of time:
Re-export will produce a different id. Here's a rough snippet to generate
IDs from headings, by replacing spaces with hyphens, for headings without IDs.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/ensure-headline-ids (&rest _)
  "Org trees without a :CUSTOM_ID: property have the property set to be their heading. All non-alphanumeric characters are replaced with ‚Äò-‚Äô.

   If multiple trees end-up with the same id property, issue a message and undo
   any property insertion thus far.
  "
  (interactive)
  (let ((ids))
    (org-map-entries
     (lambda ()
       (org-with-point-at (point)
         (let ((id (org-entry-get nil "CUSTOM_ID")))
           (unless id
             (setq id (s-replace-regexp "[^[:alnum:]]" "-" (nth 4 (org-heading-components))))
             (if (not (member id ids))
                 (push id ids)
               (message-box "Oh no, a repeated id!\n\n\t%s" id)
               (undo)
               (setq quit-flag t))
             (org-entry-put nil "CUSTOM_ID" id))))))))

;; Whenever html & md export happens, ensure we have headline ids.
(advice-add 'org-html-export-to-html :before 'my/ensure-headline-ids)
(advice-add 'org-md-export-to-markdown :before 'my/ensure-headline-ids)
#+END_SRC

One may then use ~[[#my-custom-id]]~ to link to the entry with ~CUSTOM_ID~ property
~my-custom-id~.

Interestingly, ~org-set-property~, ~C-c C-x p~, lets us insert a property from
a selection of available ones, then we'll be prompted for a value for it
from a list of values you've used elsewhere. This is useful for remaining
consistent for when trees share similar properties.

** Making then opening html's from org's
:PROPERTIES:
:CUSTOM_ID: Making-then-opening-html's-from-org's
:END:
#+BEGIN_SRC emacs-lisp
(cl-defun my/org-html-export-to-html (&optional (filename (buffer-name)))
  "Produce an HTML from the given ‚Äòfilename‚Äô, or otherwise current buffer,
   then open it in my default brower.
  "
 (interactive)
 (org-html-export-to-html)
 (let ((it (concat (file-name-sans-extension buffer-file-name) ".html")))
   (browse-url it)
   (message (concat it " has been opened in Chromium."))
   'success ;; otherwise we obtain a "compiler error".
 )
)
#+END_SRC

** Making then opening pdf's from org's
:PROPERTIES:
:CUSTOM_ID: Making-then-opening-pdf's-from-org's
:END:
#+BEGIN_SRC emacs-lisp
(cl-defun my/org-latex-export-to-pdf (&optional (filename (buffer-name)))
  "Produce a PDF from the given ‚Äòfilename‚Äô, or otherwise current buffer,
   then open it in my default viewer.
  "
 (interactive)
 (org-latex-export-to-pdf)
 (let ((it (concat (file-name-sans-extension filename) ".pdf")))
   (eshell-command (concat "open " it  " & ")))
   (message (concat it " has been opened in your PDF viewer."))
   'success ;; otherwise we obtain a "compiler error".
)
#+END_SRC

** Interpret the Haskell source blocks in a file
:PROPERTIES:
:CUSTOM_ID: Interpret-the-Haskell-source-blocks-in-a-file
:END:
#+BEGIN_SRC emacs-lisp
(defvar *current-module* "NoModuleNameSpecified"
  "The name of the module, file, that source blocks are
   currently being tangled to.

   This technique is insipired by ‚ÄúInteractive Way to C‚Äù;
   see https://alhassy.github.io/InteractiveWayToC/.
  ")

(defun current-module ()
  "Returns the current module under focus."
  *current-module*)

(defun set-module (name)
   "Set the name of the module currently under focus.

    Usage: When a module is declared, i.e., a new file has begun,
    then that source blocks header should be ‚Äú:tangle (set-module ‚Äùname-here‚Äù)‚Äù.
    succeeding source blocks now inherit this name and so are tangled
    to the same module file. How? By placing the following line at the top
    of your Org file: ‚Äú‚Äò#+PROPERTY: header-args :tangle (current-module))‚Äô.

    This technique structures ‚ÄúInteractive Way to C‚Äù.
   "
   (setq *current-module* name)
)

(cl-defun my/org-run-haskell (&optional target (filename (buffer-name)))
  "Tangle Haskell source blocks of given ‚Äòfilename‚Äô, or otherwise current buffer,
   and load the resulting ‚Äòtarget‚Äô file into a ghci buffer.

   If no name is provided for the ‚Äòtarget‚Äô file that is generated from the
   tangeling process, it is assumed to be the buffer's name with a ‚Äòhs‚Äô extension.

   Note that this only loads the blocks tangled to ‚Äòtarget‚Äô.

   For example, file ‚ÄòX.org‚Äô may have haskell blocks that tangle to files
   ‚ÄòX.hs‚Äô, ‚ÄòY.hs‚Äô and ‚ÄòZ.hs‚Äô. If no target name is supplied, we tangle all blocks
   but only load ‚ÄòX.hs‚Äô into the ghci buffer. A helpful technique to load the
   last, bottom most, defined haskell module, is to have the module declaration's
   source block be ‚Äò:tangle (setq CODE ‚ÄúY.hs‚Äù)‚Äô, for example; then the following
   code blocks will inherit this location provided our Org file has at the top
   ‚Äò#+PROPERTY: header-args :tangle (current-module))‚Äô.
   Finally, our ‚Äòcompile-command‚Äô suffices to be ‚Äò(my/org-run-haskell CODE)‚Äô.
   ‚îÄ
   This technique structures ‚ÄúInteractive Way to C‚Äù.
  "
   (let* ((it  (if target target (concat (file-name-sans-extension filename) ".hs")))
         (buf (concat "*GHCI* " it)))

     (-let [kill-buffer-query-functions nil] (ignore-errors (kill-buffer buf)))
     (org-babel-tangle it "haskell")
     (async-shell-command (concat "ghci " it) buf)
     (switch-to-buffer-other-window buf)
     (end-of-buffer)
   )
)

;; Set this as the ‚Äòcompile-command‚Äô in ‚ÄòLocal Variables‚Äô, for example.
#+END_SRC

** COMMENT Exporting Tables to CSV
:PROPERTIES:
:CUSTOM_ID: COMMENT-Exporting-Tables-to-CSV
:END:

Org-mode can export tables as TAB or comma delimited formats. I set the default format to CSV with:

(setq org-table-export-default-format "orgtbl-to-csv")
Exporting to CSV format is the only one I use and this provides the default so I can just hit RETURN when prompted for the format.

To export the following table I put the cursor inside the table and hit M-x org-table-export which prompts for a filename and the format which defaults to orgtbl-to-csv from the setting above.
** COMMENT tangeling to multiple files, org-mode
:PROPERTIES:
:CUSTOM_ID: COMMENT-tangeling-to-multiple-files,-org-mode
:END:
From https://emacs.stackexchange.com/questions/39032/tangle-the-same-src-block-to-different-files,

#+begin_src emacs-lisp :tangle no
(defun org-babel-tangle-collect-blocks-handle-tangle-list (&optional language tangle-file)
  "Can be used as :override advice for `org-babel-tangle-collect-blocks'.
Handles lists of :tangle files."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
         (org-with-wide-buffer
          (org-with-limited-levels (outline-previous-heading)))))
    (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
      (setq counter 1)
      (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
    (let* ((info (org-babel-get-src-block-info)) ;; MA: not ‚Äúlight‚Äù!
                                          ;; (describe-symbol 'org-babel-get-src-block-info)
           (src-lang (nth 0 info))
           (src-tfiles (cdr (assq :tangle (nth 2 info))))) ; Tobias: accept list for :tangle
      (unless (consp src-tfiles) ; Tobias: unify handling of strings and lists for :tangle
        (setq src-tfiles (list src-tfiles))) ; Tobias: unify handling
      (dolist (src-tfile src-tfiles) ; Tobias: iterate over list
        (unless (or (string= src-tfile "no")
            (and tangle-file (not (equal tangle-file src-tfile)))
            (and language (not (string= language src-lang))))
          ;; Add the spec for this block to blocks under its
          ;; language.
          (let ((by-lang (assoc src-lang blocks))
            (block (org-babel-tangle-single-block counter)))
        (setcdr (assoc :tangle (nth 4 block)) src-tfile) ; Tobias:
        (if by-lang (setcdr by-lang (cons block (cdr by-lang)))
          (push (cons src-lang (list block)) blocks)))))))) ; Tobias: just ()
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))

(defun org-babel-tangle-single-block-handle-tangle-list (oldfun block-counter &optional only-this-block)
  "Can be used as :around advice for `org-babel-tangle-single-block'.
If the :tangle header arg is a list of files. Handle all files"
  (let* ((info (org-babel-get-src-block-info))
     (params (nth 2 info))
     (tfiles (cdr (assoc :tangle params))))
    (if (null (and only-this-block (consp tfiles)))
    (funcall oldfun block-counter only-this-block)
      (cl-assert (listp tfiles) nil
         ":tangle only allows a tangle file name or a list of tangle file names")
      (let ((ret (mapcar
          (lambda (tfile)
            (let (old-get-info)
              (cl-letf* (((symbol-function 'old-get-info) (symbol-function 'org-babel-get-src-block-info))
                 ((symbol-function 'org-babel-get-src-block-info)
                  `(lambda (&rest get-info-args)
                     (let* ((info (apply 'old-get-info get-info-args))
                        (params (nth 2 info))
                        (tfile-cons (assoc :tangle params)))
                       (setcdr tfile-cons ,tfile)
                       info))))
            (funcall oldfun block-counter only-this-block))))
          tfiles)))
    (if only-this-block
        (list (cons (cl-caaar ret) (mapcar #'cadar ret)))
      ret)))))

(advice-add 'org-babel-tangle-collect-blocks :override #'org-babel-tangle-collect-blocks-handle-tangle-list)
(advice-add 'org-babel-tangle-single-block :around #'org-babel-tangle-single-block-handle-tangle-list)
#+end_src
* Expected IDE Support
:PROPERTIES:
:CUSTOM_ID: Expected-IDE-Support
:END:

#+BEGIN_SRC emacs-lisp
;; Use 4 spaces in places of tabs when indenting.
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)

;; Always stay indented: Automatically have blocks reindented after every change.
(use-package aggressive-indent :demand t)
(global-aggressive-indent-mode t)
#+END_SRC

** Backups
:PROPERTIES:
:CUSTOM_ID: Backups
:END:
By default, Emacs saves backup files -- those ending in ~ -- in the current directory, thereby cluttering it up. Let's place them in ~~/.emacs.d/backups~, in case we need to look for a backup; moreover,
let's keep old versions since there's disk space to go around
--what am I going to do with 500gigs when nearly all my ‚Äòsoftware‚Äô is
textfiles interpreted within Emacs üòº

#+BEGIN_SRC emacs-lisp
;; New location for backups.
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

;; Never silently delete old backups.
(setq delete-old-versions -1)

;; Use version numbers for backup files.
(setq version-control t)

;; Even version controlled files get to be backed up.
(setq vc-make-backup-files t)
#+END_SRC

Why backups? Sometimes I may forget to submit a file, or edit, to my
version control system, and it'd be nice to be able to see a local
automatic backup. Whenever ‚ÄòI need space,‚Äô then I simply empty
the backup directory, if ever. That the backups are numbered is so sweet ^_^

Like package installations, my backups are not kept in any version control
system, like git; only locally.

Let's use an elementary diff system for backups.
#+BEGIN_SRC emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+END_SRC

In a buffer that corresponds to a file, invoke ~backup-walker-start~
to see a visual diff of changes /between/ versions.
By default, you see the changes ‚Äòbackwards‚Äô: Red means
delete these things to get to the older version; i.e.,
the red ‚Äò-‚Äô are newer items.

** Editor Documentation with Contextual Information

I like [[https://github.com/Wilfred/helpful][helpful]] and wanted it to have the same behaviour as ~C-h o~, which ~helpful-at-point~ does not achieve. The incantation below makes ~C-h o~ use ~helpful~
in that if the cursour is on a symbol, then it is offered to the user as a default search item for help, otherwise a plain search box for help appears. Using a universal argument lets us drop to the built-in help command.

#+BEGIN_SRC emacs-lisp
(defun my/describe-symbol (symbol)
  "A ‚ÄúC-h o‚Äù replacement using ‚Äúhelpful‚Äù:
   If there's a thing at point, offer that as default search item.

   If a prefix is provided, i.e., ‚ÄúC-u C-h o‚Äù then the built-in
   ‚Äúdescribe-symbol‚Äù command is used.

   ‚á® Pretty docstrings, with links and highlighting.
   ‚á® Source code of symbol.
   ‚á® Callers of function symbol.
   ‚á® Key bindings for function symbol.
   ‚á® Aliases.
   ‚á® Options to enable tracing, dissable, and forget/unbind the symbol!
  "
  (interactive "p")
  (let* ((thing (symbol-at-point))
         (val (completing-read
               (format "Describe symbol (default %s): " thing)
               (vconcat (list thing) obarray)
               (lambda (vv)
                (cl-some (lambda (x) (funcall (nth 1 x) vv))
                         describe-symbol-backends))
               t nil nil))
         (it (intern val)))

    (if current-prefix-arg
        (funcall #'describe-symbol it)
      (cond
       ((or (functionp it) (macrop it) (commandp it)) (helpful-callable it))
       (t (helpful-symbol it))))))

;; Keybindings.
(global-set-key (kbd "C-h o") #'my/describe-symbol)
(global-set-key (kbd "C-h k") #'helpful-key)
#+END_SRC

** Highlight Defined Emacs Lisp Symbols

Usually Emacs only highlights macro names, the [[https://github.com/Fanael/highlight-defined][following]] incantation makes
it highlight all defined names ---as long as we're in Lisp mode, whence in
org-src blocks we use ~C-c '~.
#+BEGIN_SRC emacs-lisp
(use-package highlight-defined)
(add-hook 'emacs-lisp-mode-hook 'highlight-defined-mode)
#+END_SRC

Super helpful to avoid accidentally misspelling a word :smile:

** Highlighting TODO-s & Showing them in Magit
:PROPERTIES:
:CUSTOM_ID: Highlighting-TODO-s-&-Showing-them-in-Magit
:END:
Basic support todos. By default these include:
TODO NEXT THEM PROG OKAY DONT FAIL DONE NOTE KLUDGE HACK TEMP FIXME
and any sequence of X's or ?'s of length at least 3: XXX, XXXX, XXXXX, ‚Ä¶, ???, ????, ????, ‚Ä¶.
#+BEGIN_SRC emacs-lisp
;; NOTE that the highlighting works even in comments.
(use-package hl-todo
  :config
  ;; Enable it for text-like locations
  (add-hook 'text-mode-hook (lambda () (hl-todo-mode t)))
  ;; Adding some new keywords: TEST, WK, MA, JC.
  (add-to-list 'hl-todo-keyword-faces '("TEST" . "#dc8cc3"))
  (add-to-list 'hl-todo-keyword-faces '("MA" . "#dc8cc3"))
  (add-to-list 'hl-todo-keyword-faces '("WK" . "#dc8cc3"))
  (add-to-list 'hl-todo-keyword-faces '("JC" . "#dc8cc3"))
)
#+END_SRC

Lest these get buried in mountains of text, let's have them [[https://github.com/alphapapa/magit-todos][become
mentioned]] in a magit status buffer ---which uses the keywords from ~hl-todo~.
#+BEGIN_SRC emacs-lisp
;; MA: The todo keywords work in code too!
(use-package magit-todos
  :after magit
  :after hl-todo
  :config
  ;; For some reason cannot use :custom with this package.
  (custom-set-variables
    '(magit-todos-keywords (list "TODO" "FIXME" "MA" "WK" "JC")))
  (magit-todos-mode))
#+END_SRC

Note that such TODO keywords are not propagated from sections that are
COMMENT-ed out in org-mode.

Open a Magit status buffer, or run ~magit-todos-list~ to show a dedicated to-do
list buffer. You can then peek at items with space, or jump to them with enter.

Seeing the TODO list with each commit is an incentive to actually tackle the
items there (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

+ Inline todo keywords are pickedup if they have a colon after them; e.g.,
  TODO: Example.

** Hydra: Supply a prefix only once
:PROPERTIES:
:CUSTOM_ID: Hydra:-Supply-a-prefix-only-once
:END:
Invoke all possible key extensions having a common prefix
by supplying the prefix only once. C.f. ‚Äúhydra-zoom‚Äù from the docs.
After the prefix is supplied, all extensions are shown in a minibuffer.
#+BEGIN_SRC emacs-lisp
(use-package hydra :demand t)

;; (defhydra hydra-example (global-map "C-c v") ;; Prefix
;;   ;; List of triples (extension method description) )
#+END_SRC

See [[Taking a tour of one's edits]] below for a small and useful example.

** Taking a tour of one's edits
:PROPERTIES:
:CUSTOM_ID: Taking-a-tour-of-one's-edits
:END:
This package allows us to move around the edit points of a buffer
/without/ actually undoing anything. We even obtain a brief description
of what happend at each edit point.
This seems useful for when I get interrupted or lose my train of
thought: Just press ~C-c e ,~ to see what I did recently and where
---the ‚Äúe‚Äù is for ‚Äúe‚Äùdit.

#+BEGIN_SRC emacs-lisp
;; Give me a description of the change made at a particular stop.
(use-package goto-chg
  :init (setq glc-default-span 0))

(defhydra hydra-edits (global-map "C-c e")
  ("," goto-last-change "Goto n·µó ∞ last change")
  ("." goto-last-change-reverse "Goto more recent change"))
#+END_SRC

Compare this with ~C-x u~, or ~undo-tree-visualise~, wherein undos are actually performed.

Notice, as a hydra, I can use ~C-c e~ followed by any combination of
~,~ and ~.~ to navigate my recent edits /without/ having to supply the prefix
each time.

** What's changed & who's to blame?
:PROPERTIES:
:CUSTOM_ID: more-version-control
:END:
Let's have, in a fringe, an indicator for altered regions in a version controlled
file. Moreover, let's stage-&-commit straight from a working buffer.
The symbols ‚Äú+, =‚Äù appear in a fringe by default for alterations
---we may change these if we like.
#+BEGIN_SRC emacs-lisp
;; Hunk navigation and commiting.
(use-package git-gutter+
  :ensure t
  :init (global-git-gutter+-mode)
  :diminish (git-gutter+-mode))
#+END_SRC

Let's set a hydra so we can press ~C-x v n n p n~ to move the next two
altered hunks, move back one, then move to the next. This saves me having
to supply the prefix ~C-x v~ each time I navigate among my alterations.
At any point we may also press ~u ùï©~ to denote ~C-u ‚ü™prefix‚ü´ ùï©~.
#+BEGIN_SRC emacs-lisp
(defhydra hydra-version-control (git-gutter+-mode-map "C-x v")
  "Version control"
  ;; (extension method description)
  ("n" git-gutter+-next-hunk "Next hunk")
  ("p" git-gutter+-previous-hunk "Previous hunk")
  ("=" git-gutter+-show-hunk "Show hunk diff")
  ("r" git-gutter+-revert-hunks "Revert hunk\n")
  ("c" git-gutter+-stage-and-commit "Stage & commit hunk")
  ("C" git-gutter+-stage-and-commit-whole-buffer "Stage & commit entire buffer")
  ("U" git-gutter+-unstage-whole-buffer "Unstage whole buffer"))
#+END_SRC

Commiting with ~C-x v c~ let's us use ~C-c C-k~ to cancel and ~C-c C-c~ to
submit the given message; ~C-c C-a~ to amend the previous commit.

Besides [[https://github.com/nonsequitur/git-gutter-plus][git-gutter+]] we may use diff-hl:
#+BEGIN_SRC emacs-lisp
;; Colour fringe to indicate alterations.
;; (use-package diff-hl)
;; (global-diff-hl-mode)
#+END_SRC

A few more helpful version control features:
#+BEGIN_SRC emacs-lisp
;; Popup for who's to blame for alterations.
(use-package git-messenger :demand t)
;;
;; Message menu let's us use magit diff to see the commit change.
(setq git-messenger:use-magit-popup t)
;;
;; Always show who authored the commit and when.
;; (setq git-messenger:show-detail t)

;; View current file in browser on github.
;; More generic is ‚Äúbrowse-at-remote‚Äù.
(use-package github-browse-file)

;; Add these to the version control hydra.
;;
(defhydra hydra-version-control (git-gutter+-mode-map "C-x v")
  ("b" git-messenger:popup-message "Who's to blame?")
  ;; C-u C-x b ‚ï± u b ‚à∑ Also show who authored the change and when.
  ("g" github-browse-file-blame "Show file in browser in github")
  ("s" magit-status "Git status of current buffer"))
#+END_SRC

Perhaps ~C-x v b~ will motivate smaller, frequent, commits.

Obtaining URL links to the current location of a file
---URLs are added to the kill ring.
Usefully, if [[https://gitlab.com/pidu/git-timemachine][git-timemachine-mode]] is active, the generated link
points to the version of the file being visited.
#+BEGIN_SRC emacs-lisp
(use-package git-link)

(defhydra hydra-version-control (git-gutter+-mode-map "C-x v")
  ("l" git-link "Git URL for current location"))
#+END_SRC

Read [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Version-Control.html#Version-Control][here]] for more about version control in general.

** Edit as Root
:PROPERTIES:
:CUSTOM_ID: Edit-as-Root
:END:
From an [[http://emacs-fu.blogspot.com/2013/03/editing-with-root-privileges-once-more.html][emacs-fu blog post]]:

#+BEGIN_SRC emacs-lisp
(defun find-file-as-root ()
  "Like `ido-find-file, but automatically edit the file with
root-privileges (using tramp/sudo), if the file is not writable by
user."
  (interactive)
  (let ((file (ido-read-file-name "Edit as root: ")))
    (unless (file-writable-p file)
      (setq file (concat "/sudo:root@localhost:" file)))
    (find-file file)))

(bind-key "C-x F" 'find-file-as-root)
#+END_SRC

** COMMENT FIXME Default Compilation Commands
:PROPERTIES:
:CUSTOM_ID: COMMENT-FIXME-Default-Compilation-Commands
:END:

Emacs' [[https://www.emacswiki.org/emacs/CompileCommand][compile]] command allows us to execute arbitrary Elisp
when ~M-x recompile~ is invoked. One of my habits is to append
most of my files with the following:
#+begin_src org :tangle no
# Local Variables:
# eval: (message "Load file specific stuffs here")
# compile-command: (async-shell-command (concat "open " (org-latex-export-to-pdf)))
# End:
#+end_src

Since nearly every file I work with is ‚îÄor can be coerced into being‚îÄ in org mode,
I usually have a section ~* footer~ that contains something like the above.

Let's remove repeated matter.
#+begin_src emacs-lisp :tangle no
;; Silently save before compiling.
(setq compilation-ask-about-save nil)

;; Silently kill previous compilation process before starting a new one.
(setq compilation-always-kill t)

;; Scroll as compilation output is procuded in *Compilation* buffer; e.g., pdflatex
;; Use 'first-error to stop scrolling on the first error encountered; otherwise ‚Äòt‚Äô.
(setq compilation-scroll-output 'first-error)

;; Don't stop on informaiton messages or warnings; only on errors.
(setq compilation-skip-threshold 2)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
;; My global compile command
(setq compile-command
  '(async-shell-command (concat "open " (org-latex-export-to-pdf))))

;; Bind ‚Äòrecompile‚Äô to ‚ÄòC-c C-m‚Äô ‚îÄ‚Äúm‚Äù for ‚Äúm‚Äùake
(global-set-key (kbd "C-c C-m") 'recompile)

;; Also a helpful quick f-key.
(global-set-key (kbd "<f7>") 'recompile)
#+END_SRC
** Moving Text Around
:PROPERTIES:
:CUSTOM_ID: Moving-Text-Around
:END:

This extends Org-mode's ~M-‚Üë,‚Üì~ to other modes, such as when coding.
#+BEGIN_SRC emacs-lisp
;; M-‚Üë,‚Üì moves line, or marked region; prefix is how many lines.
(use-package move-text)
(move-text-default-bindings)
#+END_SRC

** Enabling CamelCase Aware Editing Operations
:PROPERTIES:
:CUSTOM_ID: Enabling-CamelCase-Aware-Editing-Operations
:END:
[[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][Subword]] movement lets us treat ‚ÄúEmacsIsAwesome‚Äù as three words
‚îÄ‚ÄúEmacs‚Äù, ‚ÄúIs‚Äù, and ‚ÄúAwesome‚Äù‚îÄ which is desirable since such naming
is common among coders. Now, for example, ~M-f~ moves along each subword.

#+begin_src emacs-lisp
(global-subword-mode 1)
#+end_src

** Keep buffers open across sessions                         :Disabled:
:PROPERTIES:
:CUSTOM_ID: Keep-buffers-open-across-sessions
:END:
#+begin_src emacs-lisp :tangle yes
;; Keep open files open across sessions.
(desktop-save-mode 1)
(setq desktop-restore-eager 10)
#+end_src

Not desirable since for when I want to make alterations to my Emacs system and don't
want files to remain open. Time will tell.

** Mouse Editing Support
:PROPERTIES:
:CUSTOM_ID: Mouse-Editing-Support
:END:
#+begin_src emacs-lisp
;; Text selected with the mouse is automatically copied to clipboard.
(setq mouse-drag-copy-region t)
#+end_src

** Dimming Unused Windows
:PROPERTIES:
:CUSTOM_ID: Dimming-Unused-Windows
:END:
Let's dim windows, and even the whole Emacs frame, when not in use.
#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :config (dimmer-mode))
#+END_SRC

** Having a workspace manager in Emacs
:PROPERTIES:
:CUSTOM_ID: Having-a-workspace-manager-in-Emacs
:END:

I've loved using XMonad as a window tiling manager.
I've enjoyed the ability to segregate my tasks
according to what ‚Äòproject‚Äô I'm working on;
such as research, marking, Emacs play, etc.
With [[https://github.com/nex3/perspective-el][perspective]], I can do the same thing :-)

That is, I can have a million buffers, but only those
that belong to a workspace will be visible when I'm switching between buffers, for example.

#+BEGIN_SRC emacs-lisp
(use-package perspective)

;; Activate it.
(persp-mode)

;; In the modeline, tell me which workspace I'm in.
(persp-turn-on-modestring)
#+END_SRC

All commands are prefixed by ~C-x x~; main commands:
+ ~s, n/‚Üí, p/‚Üê~ :: ‚ÄòS‚Äôelect a workspace to go to or create it, or go to ‚Äòn‚Äôext one, or go to ‚Äòp‚Äôrevious one.
+ ~c~ :: Query a perspective to kill.
+ ~r~ :: Rename a perspective.
+ ~A~ :: Add buffer to current perspective & remove it from all others.

As always, since we've installed ~which-key~, it suffices to press
~C-x x~ then look at the resulting menu üòÉ

** Jump between windows using Cmd+Arrow & between recent buffers with Meta-Tab
:PROPERTIES:
:CUSTOM_ID: Jump-between-windows-using-Cmd+Arrow-&-between-recent-buffers-with-Meta-Tab
:END:
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :config
  ;; use command key on Mac
  (windmove-default-keybindings 'super)
  ;; wrap around at edges
  (setq windmove-wrap-around t))
  #+END_SRC

The [[https://github.com/killdash9/buffer-flip.el][docs]] for the following have usage examples.
#+BEGIN_SRC emacs-lisp
(use-package buffer-flip
  :bind
   (:map buffer-flip-map
    ("M-<tab>" . buffer-flip-forward)
    ("M-S-<tab>" . buffer-flip-backward)
    ("C-g" . buffer-flip-abort))
  :config
    (setq buffer-flip-skip-patterns
        '("^\\*helm\\b"))
)
;; key to begin cycling buffers.
(global-set-key (kbd "M-<tab>") 'buffer-flip)
#+END_SRC

** Coding with a Fruit Salad: Semantic Highlighting

+ /Syntax/ highlighting ‚á® Specific words are highlighted in strong colours so that
    the /structure/ can be easily gleaned.
  - Generally this only includes a language's keywords, such as ~if, loop, begin, end , cond~.
  - User defined names generally share one colour; usually black.
  - Hence, an ~if~ block may be seen as one coloured keyword followed by
    a blob of black text.

  /Obvious keywords are highlighted while the rest remains in black!/

+ /Semantic/ highlighting ‚á® Identifiers obtain unique colouring.
  - This makes it much easier to visually spot dependencies with a quick glance.
    + One can *see* how data flows through a function.
  - In dynamic languages, this is a visual form of typing: Different colours are
    for different names.
    + Especially helpful for (library) names that are almost the same.
    + This can be accomplished anywhere in Emacs by pressing ~M-s h .~ on
      a selected phrase.

+ Here are some reads:
  - [[https://medium.com/@evnbr/coding-in-color-3a6db2743a1e][Coding in color: How to make syntax highlighting more useful]] ---an excellent, terse, read
  - [[https://zwabel.wordpress.com/2009/01/08/c-ide-evolution-from-syntax-highlighting-to-semantic-highlighting/][C++ IDE Evolution: From Syntax Highlighting to Semantic Highlighting]]
    + Names with a similar prefix share a colour, and class-local items share a colour.
  - [[https://wordsandbuttons.online/lexical_differential_highlighting_instead_of_syntax_highlighting.html][Lexical differential highlighting instead of syntax highlighting]]
    + /Ideally, the smaller the lexical difference, the greater the color difference should be./
  - [[https://github.com/jacksonrayhamilton/context-coloring][Colouring by Context]] ---an Emacs package
  - [[http://www.linusakesson.net/programming/syntaxhighlighting/][A case against syntax highlighting]]


For Emacs, [[https://github.com/ankurdave/color-identifiers-mode][Color Identifiers Mode]] gives unique highlighting to identifiers.
- It comes with support for a bunch of languages, and one can add support for others.
- It picks colours adaptively to fit the theme; one uses ~M-x color-identifiers:regenerate-colors~ after a theme change.

#+BEGIN_SRC emacs-lisp
(use-package color-identifiers-mode)
(global-color-identifiers-mode)
#+END_SRC

When writing a new name, after about ~5 seconds it obtains a colour which is then
propagated immediately to any new occurrences. This timeout before recolouring
is to avoid any lag from multithreading and can be changed by altering the following
line (#64) in the source file, changing the ~5~ to a smaller number.
#+BEGIN_SRC emacs-lisp :tangle no
(run-with-idle-timer 5 t 'color-identifiers:refresh)))
#+END_SRC

** Completion Frameworks
:PROPERTIES:
:CUSTOM_ID: Completion-Frameworks
:END:
[[http://tuhdo.github.io/helm-intro.html][Helm]] provides possible completions and also shows recently executed commands when pressing ~M-x~.

Extremely helpful for when switching between buffers, =C-x b=,
and discovering & learning about other commands!
E.g., press ~M-x~ to see recently executed commands and other possible commands!

Try and be grateful.
#+BEGIN_SRC emacs-lisp
(use-package helm
 :diminish
 :init (helm-mode t)
 :bind
  ("C-x C-r" . helm-recentf)      ; search for recently edited

  ;; Helm provides generic functions for completions to replace
  ;; tab-completion in Emacs with no loss of functionality.
  ("M-x" . 'helm-M-x)
  ;; ("C-x b". 'helm-buffers-list) ;; Avoid seeing all those *helm‚ãØ* mini buffers!
  ("C-x b". 'helm-mini) ;; see buffers & recent files; more useful.
  ("C-x r b" .'helm-filtered-bookmarks)
  ("C-x C-f" . 'helm-find-files)

  ;; A menu of all ‚Äútop-level items‚Äù in a file; e.g.,
  ;; functions and constants in source code or headers in an org-mode file.
  ;;
  ;; Nifty way to familarise yourself with a new code base, or one from a while ago.
  ;;
  ("C-c i" . 'helm-imenu)

   ;; Show all meaningful Lisp symbols whose names match a given pattern.
   ;; Helpful for looking up commands.
   ("C-h a" . helm-apropos)

   ;; Look at what was cut recently & paste it in.
   ("M-y" . helm-show-kill-ring)
)
;; (global-set-key (kbd "M-x") 'execute-extended-command) ;; Default ‚ÄúM-x‚Äù

;; Yet, let's keep tab-completetion anyhow.
(define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
(define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
;; We can list ‚Äòactions‚Äô on the currently selected item by C-z.
(define-key helm-map (kbd "C-z")  'helm-select-action)
#+END_SRC

When ~helm-mode~ is enabled, even help commands make use of it.
E.g., ~C-h o~ runs ~describe-symbol~ for the symbol at point,
and ~C-h w~ runs ~where-is~ to find the key binding of the symbol at point.
Both show a pop-up of other possible commands.

Let's ensure ~C-x b~ shows us: Current buffers, recent files, and bookmarks
‚îÄas well as the ability to create bookmarks, which is via ~C-x r b~ manually.
For example, I press ~C-x b~ then type any string and will have the option of
making that a bookmark referring to the current location I'm working in, or
jump to it if it's an existing bookmark, or make a buffer with that name,
or find a file with that name.
#+BEGIN_SRC emacs-lisp
(setq helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-bookmark-set
                                    helm-source-buffer-not-found))
#+END_SRC

Incidentally, helm even provides an [[http://tuhdo.github.io/helm-intro.html#orgheadline24][interface]] for the top program via
~helm-top~. It also serves as an interface to popular search engines
and over 100 websites such as ~google, stackoverflow~, and ~arxive~.
#+begin_src emacs-lisp
;; (shell-command "brew install surfraw &")
;;
;; Invoke helm-surfraw
#+end_src
If we want to perform a google search, with interactive suggestions,
then invoke ~helm-google-suggest~ --which can be acted for other serves,
such as Wikipedia or Youtube by ~C-z~. For more google specific options,
there is the ~google-this~ package.

Let's switch to a powerful searching mechanism -- [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]].
It allows us to not only search the current buffer but also
the other buffers and to make live edits by pressing ~C-c C-e~
when a search buffer exists. Incidentally, executing ~C-s~ on a word, region,
will search for that particular word, region; then apply changes by ~C-x C-s~.
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :bind
  (
   ("C-s"     . 'helm-swoop)           ;; search current buffer
   ("C-M-s"   . 'helm-multi-swoop-all) ;; Search all buffer
   ;; Go back to last position where ‚Äòhelm-swoop‚Äô was called
   ("C-S-s" . 'helm-swoop-back-to-last-point)
  )
 :config ;; Following from helm-swoop's github page.
   ;; Give up colour for speed.
  (setq helm-swoop-speed-or-color nil)
  ;; If this value is t, split window inside the current window
  (setq helm-swoop-split-with-multiple-windows nil)

)
#+END_SRC

:ThisBecomeMoreAnnoyingThanUseful:
#+BEGIN_SRC emacs-lisp :tangle no
  ;; If there is no symbol at the cursor, use the last used words instead.
  (setq helm-swoop-pre-input-function
      (lambda ()
        (let (($pre-input (thing-at-point 'symbol)))
          (if (eq (length $pre-input) 0)
              helm-swoop-pattern ;; this variable keeps the last used words
            $pre-input))))

#+END_SRC
:End:

Press ~M-i~ after a search has executed to enable it for all buffers.

We can also limit our search to org files, or buffers of the same mode,
or buffers belonging to the same project!

Note that on the Mac, I can still perform default Emacs search using
/Cmd+f/.

:Old_ivy_counsel_swiper_shenanigans:
+ There is a super duper neato search capability we can utilise -- ~swiper~.
+ We also use the ~counsel~, a collection of completion, ~ivy~, enhanced versions of
  common Emacs commands.
#+begin_src emacs-lisp :tangle no
(use-package ivy ;; More powerful but ugly looking completetion framework.
                 ;; Helm is prettier.
                 ;; Needed for Counsel, below.
 :config

  ;; add ‚Äòrecentf-mode‚Äô and bookmarks to ‚Äòivy-switch-buffer‚Äô.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
)

(use-package counsel
  :bind*                              ; load when pressed
  (
   ("C-s"     . swiper)
   ;; ("C-x C-r" . counsel-recentf)      ; search for recently edited
   ("<f1> l"  . counsel-find-library) ; find an Emacs Lisp library
   ("<f2> u"  . counsel-unicode-char) ; insert a unicode symbol using a pop-up
  ))
#+end_src

~swiper~ is an alternative to Emacs' default incremental search.
It shows an overview of all matches --navigate using arrow keys.
There is also a helm based version of swiper.
:end:

Finally, let's enable [[https://company-mode.github.io/][‚Äúcomplete anything‚Äù mode]]
--it ought to start in half a second and only need two characters to get going,
which means word suggestions are provided and so I need only type partial words
then tab to get the full word!
#+begin_src emacs-lisp
(use-package company
  :diminish
  :config
    (setq company-dabbrev-other-buffers t
          company-dabbrev-code-other-buffers t

          ;; Allow (lengthy) numbers to be eligible for completion.
          company-complete-number t

          ;; M-‚ü™num‚ü´ to select an option according to its number.
          company-show-numbers t

          ;; Only 2 letters required for completion to activate.
          company-minimum-prefix-length 2

          ;; Do not downcase completions by default.
          company-dabbrev-downcase nil

          ;; Even if I write something with the ‚Äòwrong‚Äô case,
          ;; provide the ‚Äòcorrect‚Äô casing.
          company-dabbrev-ignore-case t

          ;; Immediately activate completion.
          company-idle-delay 0
          )

    (global-company-mode 1)
)
;; So fast that we don't need this.
;; (global-set-key (kbd "C-c h") 'company-complete)
#+end_src
Note that ~M-/~ goes through a sequence of completions.
Note that besides the arrow keys, we can also use ~C-~ or ~M-~ with ~n, p~ to
navigate the options. Note that [[https://github.com/company-mode/company-mode/issues/360][by default]] company mode does not support completion for
phrases containing hyphens --this can be altered, if desired.

Besides boring word completition, let's add support for [[https://github.com/dunn/company-emoji][emojis]].
#+begin_src emacs-lisp
(use-package company-emoji)
(add-to-list 'company-backends 'company-emoji)
#+end_src

For example: ü•û üíª üêµ ‚úâÔ∏èüòâ üê¨ üåµ.

‚û°Ô∏èOn a new line, write ~:~ then any letter to have a tool-tip appear.
All emoji names are lowercase. ‚óÄ
# :end: does not html export nicely.

The libraries ~emojify, emojify-logos~ provides cool items like :haskell: :emacs: :org: :ruby: :python:.
Unfortunately they do not easily export to html with org-mode, so I'm not using
them.

:Alternatives:
#+BEGIN_SRC emacs-lisp
(use-package emojify
 :config (setq emojify-display-style 'image)
 :init (global-emojify-mode 1) ;; Will install missing images, if need be.
)
#+END_SRC

(use-package emojify-logos
:after emojify)

For example,
#+begin_src emacs-lisp :tangle no
 :emacs: :haskell: :org: :c: :wink: :ruby: :python: :c: :html5:
#+end_src
Yields :emacs: :haskell: :org: :c: :wink: :ruby: :python: :c: :html5:. Run ~(emojify-insert-emoji)~ to see more.

Rather than remember all of these, let's install [[https://github.com/syohex/emacs-ac-emoji][ac-emoji]]
for completion of emoji names.

(use-package ac-emoji
  :init (ac-emoji-setup)
)
:End:

Let [[https://github.com/expez/company-quickhelp][documentation pop-up]] when we pause on a completion.
This is very useful when editing in a particular coding language, say via
~C-c '~ for org-src blocks.
#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
 :config
   (setq company-quickhelp-delay 0.1)
   (company-quickhelp-mode)
)
#+END_SRC

** TODO COMMENT Snippets -- Template Expansion
:PROPERTIES:
:CUSTOM_ID: COMMENT-Snippets----Template-Expansion
:END:

It is common that there is a sequence of text that we tend to repeat
often, possibly with a name or some other parameter altered.
Such a snippet could be written once then provided by a simple
Lisp insert command with the parameters being queried. Luckily, others
have written such pleasant utilities.

[[http://joaotavora.github.io/yasnippet/snippet-development.html][Yasnippet]] is a pleasant utility for template expansion with the alluring
feature to allow arbitrary Lisp code to be executed during expansion.
The declaration of templates is verbose, requiring a particular file
hierarchy, as such I utilise [[https://github.com/Kungsgeten/yankpad][Yankpad]] which allows me to employ
an Org-mode approach: Each template corresponds to an org heading of
the form ~Key:Words:For:Expansion:Here: name of snippet here~ and the
template body is then the body of the org heading.
Any of ~Key, Words, For, Expansion, Here~ will rewrite into the body
of the org tree. This is much more terse, and I even don't bother
with that; instead preferring to tangle my templates using yankpad
as a mere interface.

#+begin_src emacs-lisp
;; Yet another snippet extension program
(use-package yasnippet
  :diminish yas-minor-mode
  :config
    (yas-global-mode 1)
    ;; respect the spacing in my snippet declarations
    (setq yas-indent-line 'fixed)
)

;; Nice ‚Äúinterface‚Äù to said program
(use-package yankpad
  ;; :if company-mode ;; load & initialise only if company-mode is defined
  :demand t
  :init
    ;; Location of templates
    (setq yankpad-file "~/.emacs.d/yankpad.org")
    (setq yankpad-category "Category: Default")
  :config
    ;; If you want to complete snippets using company-mode
    ;; (add-to-list 'company-backends #'company-yankpad)
    ;; If you want to expand snippets with hippie-expand
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    ;; Load the snippet templates -- useful after yankpad is altered
    ;; (add-hook 'after-init-hook 'yankpad-reload)
)

;; Elementary textual completion backend.
(setq company-backends
   (add-to-list 'company-backends 'company-dabbrev))
;;
;; Add yasnippet support for all company backends
;; https://emacs.stackexchange.com/a/10520/10352
;;
(defvar company-mode/enable-yas t
  "There can only be one main completition backend, so let's
   enable yasnippet/yankpad as a secondary for all completion backends.")

(defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas)
          (and (listp backend) (member 'company-yankpad backend)))
      backend
    (append (if (consp backend) backend (list backend))
            '(:with company-yankpad))))

(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+end_src

With these settings, along with the ~company~ backend, I may type a keyword
then ‚Äútab‚Äù it into expansion.

Yankpad requires we have an org file that contains our templates,
so we tangle such a file ~~/.emacs.d/yankpad.org~, and have all of our
templates be globally accessible.
#+BEGIN_SRC org :tangle "~/.emacs.d/yankpad.org"  :comments none
,#+Description: This is file is generated from my init.org; do not edit.

,* Default                                           :global:
#+end_src

Here's an example of a common template I perform by hand --no more!
I have the expected habit of copying a URL from someplace then forming
a link to it by writing ~[[URL] [description]]~, since the URL & syntax are already
known, let's expand those and place the cursour at the only unknown --the description.
#+begin_src org :tangle "~/.emacs.d/yankpad.org" :comments none
,** my-org-insert-link: cleverly insert a link copied to clipboard
 [[${1:`(clipboard-yank)`}][$2]] $0
#+end_src

What's going on here?
0. This template is expanded with the keyword ~my-org-insert-link~, then ‚Äútab‚Äù.
1. The cursour lands at position ~$1~, which has default text being the result
  of evaluating ~(clipboard-yank)~.
  # I've documented this default as being the url.

  # If I leave out the ~$(clipboard-yank)~ part, the default would simply be ~url~.

  We may evaluate Lisp code anywhere by enclosing it in backticks.

  # `(file-name-nondirectory (file-name-sans-extension (buffer-file-name)))`

2. If we're satisfied with the current field, we simply tab to the next field.
   Otherwise, we simply write text --which overwrites the default text.

3. After enough tabbing we complete the template and the cursour lands
   at position ~$0~.

‚ü™ Having default or mirrored text for ~$2~ would not allow me to see the URL
field, lest I wish to change it or at least confirm it's what I want.
Hence, the ~$2~ field has no default. ‚ü´

Let's overwrite the usual way to insert such links, via ~C-c C-l~.
#+BEGIN_SRC emacs-lisp
(cl-defun org-insert-link ()
  "Makes an org link by inserting the URL copied to clipboard
  and prompting for the link description only.

  Type over the shown link to change it, or tab to move to the description
  field.

  This overrides Org-mode's built-in ‚Äòorg-insert-link‚Äô utility.
  "
  (interactive)
  (insert "my-org-insert-link")
  (yankpad-expand)
)
#+END_SRC

The [[http://joaotavora.github.io/yasnippet/snippet-development.html][Yasnippe manual]] is an accessible read, as is the
 [[https://github.com/Kungsgeten/yankpad][Yankpad manual]], and showcases many other utilities; such as
having certain snippets being activated enabled only in particular
modes or on demand. Of note is that field ~$n~ can be accessed in
code with the invocation ~(yas-field-value n)~.

The rest of this section is other templates, not much for now,
concluding with actually loading this snippet mechanism globally.

*** Org-mode Templates --A reason I ‚Äúgenerate‚Äù templates ;)
:PROPERTIES:
:CUSTOM_ID: Org-mode-Templates---A-reason-I-‚Äúgenerate‚Äù-templates-;)
:END:

This produces a pop-up list of org-mode block types, if ~src~ is
selected, then a list of my commonly used languages pops-up.
Alternatively, ignore the pop-up menu and write any block or language name.
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** begin: produce an org-mode block
,#+begin_${1:environment$(let*
    ((block '("src" "example" "quote" "verse" "center" "latex" "html" "ascii"))
     (langs '("c" "emacs-lisp" "lisp" "latex" "python" "sh" "haskell" "plantuml" "prolog"))
     (type (yas-choose-value block)))
     (concat type (when (equal type "src") (concat " " (yas-choose-value langs)))))}
 $0
,#+end_${1:$(car (split-string yas-text))}
#+END_SRC
In this case, ~yas-text~ is equivalent to (~yas-field-value 1)~;
it generally refers to the value of the field being mirrored with ~${n: ‚ãØyas-text‚ãØ}~.

However, going through pop-ups takes precious time.
Let's introduce a template for my most utilised kind of language blocks.
#+begin_src org :tangle no
,** s-el: Elisp org-block
,#+begin_src emacs-lisp
$0
,#+end_src
#+end_src

However, doing this for each language I want is a waste of time
and textual space. Why? The purpose of templates is to reduce repetition,
yet the above block would be repeated with only 3 parts ‚Äòunknown‚Äô:
The expansion keyword, the description, and the org-mode source block name.
Whence,
#+name: make-lang-template
#+begin_src emacs-lisp :tangle yes
(defun make-lang-template (key lang)
  "We make an org-mode source block snippet template.

  ‚Äòkey‚Äô is the expansion word key for the language ‚Äòlang‚Äô;
  the description for the snippet is also ‚Äòlang‚Äô.
  "
  (s-join "\n" `(
    ,(concat "** " key ": " lang)
    ,(concat "#+begin_src " lang)
    "$0"
    "#+end_src"
    "\n"
  ))
)
#+end_src

The template /text/ is then generated by the following simple loop
--whose source block is named ~my-org-lang-templates~.
#+NAME: my-org-lang-templates
#+begin_src emacs-lisp :tangle no :wrap "src org :tangle ~/.emacs.d/yankpad.org" :exports code :results replace drawer
(let (result) ;; ensure result is initially empty
   (dolist (x '( ("s_el" . "emacs-lisp")
                 ("s_org" . "org")
                 ("s_hs" . "haskell")
                 ("s_ag" . "agda2")
                 ("s_c" . "c")
                 ("s_lx" . "latex")
               ) result)
      (setq result (concat result "\n" (make-lang-template (car x) (cdr x))))))
#+end_src

hi
# #+begin_src emacs-lisp :tangle no :wrap "src org :tangle ~/.emacs.d/yankpad.org" :exports code :results replace drawer
#+BEGIN_SRC emacs-lisp :wrap "src org" :results_switches ":tangle nice.txt"
"hello"
#+END_SRC

#+RESULTS:
#+begin_src org
hello
#+end_src


The /resulting text/ of this block is tangled to our yankpad; an example of the
resulting text is:
#+begin_example
,** s_el: emacs-lisp
,#+begin_src emacs-lisp
$0
,#+end_src
#+end_example


The /resulting text/ of this block, generated below, is tangled to our yankpad
by utilising a [[https://www.gnu.org/software/emacs/manual/html_node/org/Noweb-reference-syntax.html][noweb]] source block invocation:
#+begin_src org :tangle no
,#+begin_src org :tangle "~/.emacs.d/yankpad.org" :noweb yes
<<my-org-lang-templates()>>
,#+end_src
#+end_src
#+begin_src org  :tangle "~/.emacs.d/yankpad.org" :noweb yes :comments none
<<my-org-lang-templates()>>
#+end_src
#
# The ‚Äú:eval never-export‚Äù means that this block is never tangled on document
# export, C-c C-e.

Now ~s-~, due to company mode, brings up a list of languages
that I can then simply scroll down through, then ‚Äúenter‚Äù upon to
expand. Moreover, the prefix ~s-~ means that the key is mostly irrelevant,
since I needn't remember it because company-mode immediately lists possible completions.
Super neat stuff :-)

Ain't this reminiscent of meta-programming ;-)

‚ü™ Incidentally, I originally wrote an Elisp script to temporarily
open the yankpad, then append the desired text. However, such
an approach is brittle: I have to manually execute said script.

In contrast, using noweb invocations to tangle the results is
more flexible: Any time the tangling is performed, the yankpad
is kept up to date --no personal intervention from myself.

Observe that noweb could be utilised in a similar fashion to
[[https://www.wisdomandwonder.com/article/10603/two-ways-to-share-static-key-pair-values-across-different-tangled-source-files-with-org-mode-literate-programming][share key-value pairs across different source files]].
‚ü´

# Neat, but not what I want.
# https://github.com/abo-abo/auto-yasnippet

:Old_approach:
Now we invoke the following incantation once so that...

#+BEGIN_SRC emacs-lisp :tangle no
(with-temp-buffer

   (find-file "~/.emacs.d/yankpad.org")
   (end-of-buffer)

   (dolist (x '( ("s-el" . "emacs-lisp")
                 ("s-hs" . "haskell")
                 ("s-ag" . "agda2")
                 ("s-c" . "c")
                 ("s-lx" . "latex")
               ))
      (insert (make-lang-template (car x) (cdr x))))

   (save-buffer)
   (kill-buffer)
   (yankpad-reload)
)
#+END_SRC

(yankpad-reload)
:End:

:Fun_albeit_useless_exercise:

Let's push this frontier a bit more ‚Ä¶

In expressive languages like Agda, one can not only be type polymorphic
but also ‚Äòlevel polymorphic‚Äô --since types constitute a hierarchy
where a ‚Äòtype‚Äô is uninterestingly an ‚Äòelement‚Äô of a higher ‚Äòtype‚Äô, ad infinitum.
For example, the type of a level polymorphic ‚Ä≤choice‚Äô function would
~{a : Level} (A : Set a) ‚Üí A~ --note that such a choice function cannot
exist since for any type ~A~ it returns an element of ~A~, then what of the empty
type. Anyhow, the template ~{${1:a} : Level} ‚Üí (${2:A} : Set $1) ‚Üí $0~
would suffice to make this happen. Yet, what if we wanted
/n/-many sets?

Make a function that takes /n ‚â§ 26/ as input, produces a list of
levels, then uses each level to produce a list of type names ;-)
Exercise to the interested (source code) reader
-- ping me, if you have questions.
:End:
*** Elisp Templates
:PROPERTIES:
:CUSTOM_ID: Elisp-Templates
:END:
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** loop:  Elisp's for each loop
(dolist (${1:var} ${2:list-form})
        ${3:body})

,** defun: Lisp functions
(cl-defun ${1:fun-name} (${2:arguments})
  "${3:documentation}"
  $0
)

,** cond: Elisp conditionals
(cond (${1:scenario‚ÇÅ} ${2:response‚ÇÅ})
      (${3:scenario‚ÇÇ} ${4:response‚ÇÇ})
)
#+end_src

*** Equational Templates
:PROPERTIES:
:CUSTOM_ID: Equational-Templates
:END:
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** fun: Function declaration with type signature

${1:fun-name} : ${2:arguments}
$1 ${3:args} = ?$0

,** eqn_begin: Start a ‚â°-Reasoning block in Agda

begin
  ${1:left-hand-side}
‚â°‚ü® ${3:reason-for-the-equality} ‚ü©
  ${2:right-hand-side}
$0‚àé

,** eqn_step: Insert a step in a ‚â°-Reasoning block in Agda
‚â°‚ü® ${2:reason-for-the-equality} ‚ü©
  ${1:new-expression}
$0
#+end_src

*** Misc Templates
:PROPERTIES:
:CUSTOM_ID: Misc-Templates
:END:
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** remark: top-level literate comment

{{{remark(${1:thoughts})}}} $0
#+end_src

Where my local use contains ~#+MACRO: remark  @@latex: \fbox{\textbf{Comment: $1 }}@@~.

***  Re-Enabling Templates
:PROPERTIES:
:CUSTOM_ID: Re-Enabling-Templates
:END:
After our yankpad templates are generated, we need to load it.
#+BEGIN_SRC emacs-lisp
;; After init hook; see above near use-package install.
(yankpad-reload)
#+END_SRC
** COMMENT On the fly syntax checking
:PROPERTIES:
:CUSTOM_ID: COMMENT-On-the-fly-syntax-checking
:END:
#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :defer 2
  :init (global-flycheck-mode)
  :custom
  (flycheck-display-errors-delay .3))
#+end_src

:Ignore:
https://emacs.stackexchange.com/questions/7844/org-mode-have-flycheck-resolve-relative-config-while-editing-code-blocks
#+begin_src emacs-lisp :tangle no
(defadvice org-edit-src-code (around set-buffer-file-name activate compile)
  (let ((file-name (buffer-file-name)))
    ad-do-it
    (setq buffer-file-name file-name)))
#+end_src

In an org-src block, we press ~C-c '~ to get into the language's
mode where flycheck will provide many warnings.
#+begin_src haskell :tangle no
module Main where

main :: IO ()
main = putStrLn $ "nice" ++ f 0

f :: Int -> String
f x = x -- show x
-- type error
#+end_src

:End:
** Text Folding with [[https://github.com/gregsexton/origami.el][Origami-mode]]

Let's use a feature-full folding mode.
#+BEGIN_SRC emacs-lisp
(use-package origami)
#+END_SRC

With basic support for one of my languages.
#+BEGIN_SRC emacs-lisp
(push (cons 'agda2-mode (origami-markers-parser "{-" "-}"))
      origami-parser-alist)
#+END_SRC

With expected support for searching.
#+BEGIN_SRC emacs-lisp
(defun my/search-hook-function ()
  (when origami-mode (origami-toggle-node (current-buffer) (point))))

;; Open folded nodes if a search stops there.
(add-hook 'helm-swoop-after-goto-line-action-hook #'my/search-hook-function)
;;
;; Likewise for incremental search, isearch, users.
;; (add-hook 'isearch-mode-end-hook #'my/search-hook-function)
#+END_SRC

Along with a hydra for super quick navigation and easily folding, unfolding blocks! Love this one ^_^
#+BEGIN_SRC emacs-lisp
(defhydra folding-with-origami-mode (global-map "C-c f")
  ("h" origami-close-node-recursively "Hide")
  ("o" origami-open-node-recursively  "Open")
  ("t" origami-toggle-all-nodes  "Toggle buffer")
  ("n" origami-next-fold "Next")
  ("p" origami-previous-fold "Previous"))
#+END_SRC

* Helpful Utilities & Shortcuts
:PROPERTIES:
:CUSTOM_ID: Helpful-Utilities-&-Shortcuts
:END:

:PROPERTIES:
:CUSTOM_ID: Helpful-Utilities-&-Shortcuts
:END:

Here is a collection of Emacs-lisp functions that I have come to use in other files.
# The subsections below detail the definitions.

Disclaimer: I wrote much of the following /before/ I learned any lisp; everything below is probably terrible.

Let's save a few precious seconds,
#+begin_src emacs-lisp
;; change all prompts to y or n
(fset 'yes-or-no-p 'y-or-n-p)

;; Enable ‚Äòpossibly confusing commands‚Äô
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
#+end_src

** Bind ~recompile~ to ~C-c C-m~ -- ‚Äúm‚Äù for ‚Äúm‚Äùake
:PROPERTIES:
:CUSTOM_ID: Bind-~recompile~-to-~C-c-C-m~----‚Äúm‚Äù-for-‚Äúm‚Äùake
:END:
#+BEGIN_SRC emacs-lisp
(defvar my-keys-minor-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-m") 'recompile)
    map)
  "my-keys-minor-mode keymap.")

(define-minor-mode my-keys-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  :init-value t
  :lighter " my-keys")

(my-keys-minor-mode)

(diminish 'my-keys-minor-mode) ;; Don't show it in the modeline.
#+END_SRC
** Reload buffer with ~f5~
:PROPERTIES:
:CUSTOM_ID: Reload-buffer-with-~f5~
:END:
I do this so often it's not even funny.
#+BEGIN_SRC emacs-lisp
(global-set-key [f5] '(lambda () (interactive) (revert-buffer nil t nil)))
#+END_SRC

In Mac OS, one uses ~Cmd-r~ to reload a page and Emacs binds buffer reversion to ~Cmd-u~
--in Emacs, Mac's ~Cmd~ is referred to as the ‚Äòsuper key‚Äô and denoted ~s~.

Moreover, since I use Org-mode to generate code blocks and occasionally
inspect them, it would be nice if they automatically reverted when they
were regenerated --Emacs should also prompt me if I make any changes!

#+begin_src emacs-lisp
;; Auto update buffers that change on disk.
;; Will be prompted if there are changes that could be lost.
(global-auto-revert-mode 1)
#+end_src

** Kill to start of line
:PROPERTIES:
:CUSTOM_ID: Kill-to-start-of-line
:END:
Dual to ~C-k~,
#+BEGIN_SRC emacs-lisp
;; M-k kills to the left
(global-set-key "\M-k" '(lambda () (interactive) (kill-line 0)) )
#+END_SRC
** ~file-as-list~ and ~file-as-string~
:PROPERTIES:
:CUSTOM_ID: ~file-as-list~-and-~file-as-string~
:END:

Disclaimer: I wrote the following /before/ I learned any lisp; everything below is probably terrible.
#+BEGIN_SRC emacs-lisp
(defun file-as-list (filename)
  "Return the contents of FILENAME as a list of lines"
  (with-temp-buffer
    (insert-file-contents filename)
    (split-string (buffer-string))))

(defun file-as-string (filename)
  "Return the contents of FILENAME as a list of lines"
  (with-temp-buffer
    (insert-file-contents filename)
    (buffer-string)))
#+END_SRC

** ~C-x k~ kills current buffer, ~C-u C-x k~ kills all others
:PROPERTIES:
:CUSTOM_ID: kill-buffers
:END:

Let's introduce a handy utility when I'd like to clean my buffers.
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers and other windows."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
  (delete-other-windows))
#+END_SRC

By default ~C-x k~ prompts to select which buffer
should be selected. I almost always want to kill
the current buffer, so let's not waste time making
such a tedious decision.
#+begin_src emacs-lisp
(global-set-key (kbd "C-x k")
  '(lambda (&optional all)
     "Kill current buffer, or all if prefix is provided.
      Prompt only if there are unsaved changes."
     (interactive "P")
     (if all (kill-other-buffers)
       (kill-buffer (current-buffer)))))
#+end_src

** Switching from 2 horizontal windows to 2 vertical windows
:PROPERTIES:
:CUSTOM_ID: Switching-from-2-horizontal-windows-to-2-vertical-windows
:END:
I often find myself switching from a horizontal view of two windows in Emacs to a
vertical view. This requires a variation of ~C-x 1 RET C - x 3 RET C-x o X-x b RET~.
Instead I now only need to type ~C-|~ to make this switch.
#+BEGIN_SRC emacs-lisp
(defun ensure-two-vertical-windows ()
  "I used this method often when programming in Coq."
 (interactive)
 (other-window 1)			;; C-x 0
 (let ((otherBuffer (buffer-name)))
   (delete-window)			;; C-x 0
   (split-window-right)			;; C-x 3
   (other-window 1)			;; C-x 0
   (switch-to-buffer otherBuffer)	;; C-x b RET
 )
 (other-window 1)
)
(global-set-key (kbd "C-|") 'ensure-two-vertical-windows)
#+END_SRC
** ~re-replace-in-file~
:PROPERTIES:
:CUSTOM_ID: ~re-replace-in-file~
:END:

Disclaimer: I wrote the following /before/ I learned any lisp; everything below is probably terrible.
#+BEGIN_SRC emacs-lisp
(defun re-replace-in-file (file regex whatDo)
   "Find and replace a regular expression in-place in a file.

   Terrible function ‚Ä¶ before I took the time to learn any Elisp!
   "

    (find-file file)
    (goto-char 0)
    (let ((altered (replace-regexp-in-string regex whatDo (buffer-string))))
      (erase-buffer)
      (insert altered)
      (save-buffer)
      (kill-buffer)
   )
)
#+END_SRC

Example usage:
#+BEGIN_EXAMPLE emacs-lisp
;; Within mysite.html we rewrite: <h1.*h1>   ‚Ü¶   <h1.*h1>\n NICE
;; I.e., we add a line break after the first heading and a new word, ‚ÄúNICE‚Äù.
(re-replace-in-file "mysite.html"
                    "<h1.*h1>"
                    (lambda (x) (concat x "\n NICE")))
#+END_EXAMPLE

*** ~mapsto~: Simple rewriting for current buffer
:PROPERTIES:
:CUSTOM_ID: ~mapsto~:-Simple-rewriting-for-current-buffer
:END:
#+BEGIN_SRC emacs-lisp
(defun mapsto (this that)
  "In the current buffer make the regular expression rewrite: this ‚Ü¶ that."
  (let* ((current-location (point))
       ;; Do not alter the case of the <replacement text>.
       (altered (replace-regexp-in-string this (lambda (x) that) (buffer-string) 'no-fixed-case))
       )
      (erase-buffer)
      (insert altered)
      (save-buffer)
      (goto-char current-location)
  )
)
#+END_SRC

** Obtaining Values of ~#+KEYWORD~ Annotations
:PROPERTIES:
:CUSTOM_ID: Obtaining-Values-of-~#+KEYWORD~-Annotations
:END:

Org-mode settings are, for the most part, in the form ~#+KEYWORD: VALUE~. Of notable interest
are the ~TITLE~ and ~NAME~ keywords. We use the following ~org-keywords~ function to obtain
the values of arbitrary ~#+THIS : THAT~ pairs, which may not necessarily be supported by native
Org-mode --we do so for the case, for example, of the ~CATEGORIES~ and ~IMAGE~ tags associated with an article.

# Parse org buffer as an elisp structure: https://emacs.stackexchange.com/questions/2869/turn-a-list-or-data-structure-into-an-org-document#
#+BEGIN_SRC emacs-lisp
;; Src: http://kitchingroup.cheme.cmu.edu/blog/2013/05/05/Getting-keyword-options-in-org-files/
(defun org-keywords ()
  "Parse the buffer and return a cons list of (property . value) from lines like: #+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
                   (lambda (keyword) (cons (org-element-property :key keyword)
                                           (org-element-property :value keyword)))))

(defun org-keyword (KEYWORD)
  "Get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (org-keywords))))
#+END_SRC

Note that capitalisation in a ‚Äù#+KeyWord‚Äù is irrelevant.

See [[https://orgmode.org/manual/Org-syntax.html][here]] on how to see the abstract syntax tree of an org file
and how to manipulate it.

** Quickly pop-up a terminal, run a command, close it
:PROPERTIES:
:CUSTOM_ID: Quickly-pop-up-a-terminal,-run-a-command,-close-it
:END:
#+begin_src emacs-lisp
(cl-defun toggle-terminal (&optional (name "*eshell-pop-up*"))
   "Pop up a terminal, do some work, then close it using the same command.

   The toggle behaviour is tied into the existence of the pop-up buffer.
   If the buffer exists, kill it; else create it.
   "
   (interactive)
   (cond
     ;; when the terminal buffer is alive, kill it.
     ((get-buffer name)  (kill-buffer name)
                         (ignore-errors (delete-window)))
     ;; otherwise, set value to refer to a new eshell buffer.
     (t                  (split-window-right)
                         (other-window 1)
                         (eshell)
                         (rename-buffer name))
   )
)

(global-set-key "\C-t" 'toggle-terminal)
#+end_src

** Publishing articles to my personal blog
:PROPERTIES:
:CUSTOM_ID: Publishing-articles-to-my-personal-blog
:END:

I try to [[https://alhassy.github.io/][blog]] occasionally, so here's a helpful function to quickly
publish the current article to my blog.
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cb" 'my/publish-to-blog)

(cl-defun my/publish-to-blog (&optional (draft nil) (local nil))
  "
  Using ‚ÄòAlBasmala‚Äô setup to publish current article to my blog.
  Details of AlBasmala can be found here:
  https://alhassy.github.io/AlBasmala/

  Locally: ~/alhassy.github.io/content/AlBasmala.org

  A ‚Äòdraft‚Äô will be produced in about ~7 seconds, but does not re-produce
  a PDF and the article has a draft marker near the top. Otherwise,
  it will generally take ~30 seconds due to PDF production, which is normal.
  The default is not a draft and it takes ~20 seconds for the live
  github.io page to update.

  The ‚Äòlocal‚Äô optiona indicates whether the resulting article should be
  viewed using the local server or the live webpage. Live page is default.

  When ‚Äòdraft‚Äô and ‚Äòlocal‚Äô are both set, the resulting page may momentarily
  show a page-not-found error, simply refresh.
  "

  (load-file "~/alhassy.github.io/content/AlBasmala.el")

  ;; --MOVE ME TO ALBASMALA--
  ;; Sometimes the file I'm working with is not a .org file, so:
  (setq file.org (buffer-name))

  (preview-article :draft draft)
  (unless draft (publish))
  (let ((server (if local "http://localhost:4000/" "https://alhassy.github.io/")))
    (async-shell-command (concat "open " server NAME "/") "*blog-post-in-browser*"))
)
#+END_SRC

** Excellent PDF Viewer
:PROPERTIES:
:CUSTOM_ID: Excellent-PDF-Viewer
:END:
Let's install the [[https://github.com/politza/pdf-tools][pdf-tools]] library for viewing PDFs in Emacs.
#+BEGIN_SRC emacs-lisp
;; First: (async-shell-command "brew install --HEAD dunn/homebrew-emacs/pdf-tools")

;; Then:
(use-package pdf-tools
  :ensure t
  :config
  (custom-set-variables
    '(pdf-tools-handle-upgrades nil))
  (setq pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo"))

;; Finally:
(pdf-tools-install)

;; Now PDFs opened in Emacs are in pdfview-mode.
#+END_SRC

Besides the expected PDF viewing utilities, such as search, annotation, and continuous scrolling;
with a simple mouse right-click, we can even select a ‚Äòmidnight‚Äô rendering mode which may be
easier on the eyes. For more, see the brief [[https://www.dailymotion.com/video/x2bc1is][pdf-tools-tourdeforce]] demo.
* Undo tree                                                        :noexport:
:PROPERTIES:
:CUSTOM_ID: Undo-tree
:END:

# Todo: Learn about weaving so that presentation order may differ from code tangeling order.

#+begin_src emacs-lisp :tangle yes
;; Allow tree-semantics for undo operations.
(package-install 'undo-tree)
(global-undo-tree-mode)
(diminish 'undo-tree-mode)

;; Execute (undo-tree-visualize) then navigate along the tree to witness
;; changes being made to your file live!

;; Each node in the undo tree should have a timestamp.
(setq undo-tree-visualizer-timestamps t)

;; Show a diff window displaying changes between undo nodes.
(setq undo-tree-visualizer-diff t)
#+end_src

* COMMENT TODO Improvements
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-Improvements
:END:
+ [ ] Consider moving emots, such as \csi and \whyme, into yassnipets.

** COMMENT TODO Macros
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-Macros
:END:

Here's a neat macro I made, but I /may/ avoid using it in the init in order to
avoid scaring anyone. I may use it in my personal stuff.

#+BEGIN_SRC emacs-lisp
(defmacro Œª (&rest body)
  "Implementing Z-notation style, interactive, lambdas; ideally for inline use:

   ‚ÄúŒª Œ± Œ≤ ‚Ä¶ œâ ‚Ä¢ body‚Äù  becomes an interactive function with arguments Œ±, ‚Ä¶, œâ.

   The args list may be empty, in which case the separator ‚Äú‚Ä¢‚Äù may be omitted
   entirely, if desired.
  "

  (let* ((parts (-split-on '‚Ä¢ body)) args rest)

    (if (<= 2 (length parts))
        (progn (setq args (car parts)) (setq rest (cadr parts)))
         ;; Otherwise, only one part was found ---no arguments were provided.
         (setq args nil) (setq rest (car parts)))

   `(lambda ,args (interactive) ,@rest)
  ))

;; Some tests

(setq f (Œª x y ‚Ä¢ (+ x y)))   ;; ‚áí (lambda (x y) (interactive) (+ x y))
(setq g (Œª ‚Ä¢ 'neato "woah")) ;; ‚áí (lambda (x y) (interactive) 'neato "woah")
(setq h (Œª "bye" 'bye))      ;; ‚áí (lambda (x y) (interactive) "bye" 'bye)
(funcall f 1 2)
(funcall g)
(funcall h)

;; intended use case

(local-set-key (kbd "C-x x x") (lambda () (interactive) (message-box "Test!")))
(local-set-key (kbd "C-x x x") (Œª (message-box "Terse!")))
#+END_SRC

** COMMENT TODO Summary of Utilities Provided
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-Summary-of-Utilities-Provided
:END:

| _Command_                                | _Action_                                                |
| ~C-c C-m~                                | recompile file                                          |
| ~<f5>~                                   | revert buffer                                           |
| ~M-x k~                                  | kill to start of line                                   |
| ~C-‚à£~                                    | toggle 2 windows from horizontal to vertical view       |
| ~(file-as-list   pathHere)~              | construe a file as a list of lines                      |
| ~(file-as-string pathHere)~              | construe a file as a string                             |
| (~re-replace-in-file file regex whatDo)~ | perform an in-file regular expression rewrite           |
| ~(mapsto this that)~                     | regex rewrite in current buffer: this ‚Ü¶ that            |
| ~M-x create-scratch-buffer~              | --self evident--                                        |
| ~M-x kill-other-buffers~                 | --self evident--                                        |
| ~M-$~                                    | check spelling of word at point                         |
| ~M-#~                                    | thesaurus look-up word at point                         |
| ~(my/org-run-haskell &optional file)~    | Interpret the Haskell org-blocks from a file into ghci. |
| ~C-+/-~                                  | increase/decrease text size                             |
| ~M-x my-org-html-export-to-html~         | make then open html from an org file                    |
| ~C-c C-c~                                | execute code in an org ~src~ block                      |
| ~<E~                                     | produce an emacs-lisp ~src~ block                       |
| ~<g~                                     | produce a graph template ~src~ block                    |
| ~C-x t~                                  | open a new untitled org template file                   |
| ~(org-keywords)~                         | get ~#+Property: Value~ pairs from an org file          |
| ~(org-keyword property)~                 | get the ~value~ of a given org ~#+property~             |

Since I'm using ~use-package~, I can invoke ~M-x describe-personal-keybindings~ to see what key bindings I've defined.
Since not all my bindings are via ~use-package~, it does not yet cover all of my bindings.

We could run ~C-h b~ to see our bindings:
#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :defer t
  :bind (("C-h b" . helm-descbinds)))
#+END_SRC

Finally, we can observe which features are active in our current Emacs with,
#+begin_src emacs-lisp :tangle no
(message "Features: %s" features)
#+end_src

# List of installed packages: (mapcar 'car package-alist)
** COMMENT TODO Stuff I don't really use, but may want to look at later
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-Stuff-I-don't-really-use,-but-may-want-to-look-at-later
:END:
*** hooks and things for literate agda with org-agda
:PROPERTIES:
:CUSTOM_ID: hooks-and-things-for-literate-agda-with-org-agda
:END:
#+BEGIN_SRC emacs-lisp  :tangle no
;; not needed
(defun lagda-extension-whatdo ()
       "What to do when encountering a .lagda file.
       To be added to auto-mode-list."
       (agda2-mode)
       (org-babel-load-file "~/Dropbox/lagda-with-org.org")
       (message "Musa's special Agda settings enabled."))

(add-to-list 'auto-mode-alist '("\\.lagda\\'" . (lambda () (lagda-extension-whatdo))))
; (add-to-list 'auto-mode-alist '("\\.lagda\\'" . 'lagda-extension-whatdo))

(defun my-add-to-multiple-hooks (function hooks) (mapc (lambda (hook) (add-hook hook function)) hooks))
(defun my-common-hook () (fci-mode) (orgstruct-mode) )
(my-add-to-multiple-hooks 'my-common-hook '(text-mode-hook agda2-mode-hook))
#+END_SRC
*** floating toc material                            :no_longer_using_this:
:PROPERTIES:
:CUSTOM_ID: floating-toc-material
:END:

Add the following to a web-page if you'd like it to have a floating table of contents.
+ Perhaps consider making this a default for all org-files?
 + The ~floatingTocStyle.css~ lives in my Dropbox; bring it here to be self-contained.

#+BEGIN_SRC org :tangle no
#+HTML: <small><center>
( Please remember that you can always access a section using the floating table of contents at the upper-right corner of your screen. )
#+HTML: </center></small>
#+HTML_HEAD: <link rel=\"stylesheet\" type=\"text/css\" href=\"floatingTocStyle.css\" />
#+HTML: <div id=\"toc\"> &nbsp;Table of Contents&nbsp; <small> <div id=\"full\">
#+TOC: headlines 2
#+HTML: </div> </small> </div>
#+END_SRC

*** org-html-postamble-format
:PROPERTIES:
:CUSTOM_ID: org-html-postamble-format
:END:
 Look at the super short doc to know how to manipulate this variable.
 (describe-symbol 'org-html-postamble-format)

 #+BEGIN_SRC emacs-lisp :tangle no
(defun make-html-link (url identifier)
  (concat "<a href=\"" url "\">" identifier "</a>"))

(setq org-html-postamble-format
  (let* ((nomorg (buffer-name))
         (nom    (file-name-sans-extension nomorg))
         (src    (make-html-link nomorg "Org Source"))
         (nompdf (concat nom ".pdf"))
         (pdf    (make-html-link nompdf "View me as a PDF"))
        )
`(("en" ,(concat "<center> Last modified on %C ; " pdf " ; " src " ; Contact me at %e </center>"))))
)
 #+END_SRC
*** to-consider-for-magit-list-repositories
:PROPERTIES:
:CUSTOM_ID: to-consider-for-magit-list-repositories
:END:

The above mechanism suffices, the following needn't be followed with ... unless desired

#+begin_src emacs-lisp :tangle no
(add-to-list 'magit-repository-directories '("~/dotfiles"          . 0))
(add-to-list 'magit-repository-directories '("~/alhassy.github.io" . 0))
(add-to-list 'magit-repository-directories '("~/MyUnicodeSymbols"  . 0))
(add-to-list 'magit-repository-directories '("~/CheatSheet"        . 0))
(add-to-list 'magit-repository-directories '("~/ElispCheatSheet"   . 0))

;; Likely want to put a hook when closing emacs, or at some given time,
;; to show me this buffer so that I can ‚Äòpush‚Äô if I haven't already!
;
; (magit-list-repositories)

(progn (eshell-command "echo change-here >> ~/ElispCheatSheet/CheatSheet.org")
       (magit-anything-modified-p t "~/ElispCheatSheet")
       (magit-status "~/ElispCheatSheet/CheatSheet.org")
)

(dolist (file (directory-files "~/ElispCheatSheet") nil)
     (magit-refresh)
     (when (magit-anything-modified-p t file)
       (message-box (format "%s" file)) )
)

(describe-symbol 'magit-list-repositories)

(magit-repo-list-mode

(catch 'break
  (dolist (repo magit-repository-directories nil)

  )))

(defun tangle-commit-load ()
  (interactive)
  (save-excursion
    (widen)
    (save-buffer)
    (org-babel-tangle)
    (magit-stage-modified)
    (magit-commit-create)
    (load-file user-init-file)
    (delete-other-windows)))
#+end_src

*** Programming Language Support                                     :TODO:
:PROPERTIES:
:CUSTOM_ID: Programming-Language-Support
:END:

***** Haskell :tangle no
:PROPERTIES:
:CUSTOM_ID: Haskell-:tangle-no
:END:
#+BEGIN_SRC emacs-lisp
;; now C-c C-l interpets the current buffer; will ofcourse need to switch to the ghci buffer
 (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
#+END_SRC

***** Kotlin
:PROPERTIES:
:CUSTOM_ID: Kotlin
:END:
#+BEGIN_SRC emacs-lisp  :tangle no
(load "~/.emacs.d/kotlin-mode.el")
(setq kotlin-tab-width 2)
#+END_SRC

***** Lambda Prolog
:PROPERTIES:
:CUSTOM_ID: Lambda-Prolog
:END:
#+BEGIN_SRC emacs-lisp  :tangle no
(load "/usr/local/packages/teyjus/emacs/teyjus.el")
(setq tjcc "/usr/local/packages/teyjus/tjcc")
#+END_SRC
***** intero and haskell
:PROPERTIES:
:CUSTOM_ID: intero-and-haskell
:END:

  ;; ;;; To get completions in the REPL
  ;; (add-hook 'haskell-interactive-mode-hook 'company-mode)

  (require 'intero)
  (add-hook 'haskell-mode-hook 'intero-mode)
  (add-hook 'literate-haskell-mode-hook 'intero-mode)
  ;; needed to fix bug when loading stack ghci for > 8.2
  (setq haskell-process-args-ghci
        '("-ferror-spans" "-fshow-loaded-modules"))

  (setq haskell-process-args-cabal-repl
        '("--ghc-options=-ferror-spans -fshow-loaded-modules"))

*** Coq Support
:PROPERTIES:
:CUSTOM_ID: Coq-Support
:END:
Sometimes I use Coq,
#+begin_src emacs-lisp
;; Open .v files with Proof General's Coq mode
;; (load "~/.emacs.d/lisp/PG/generic/proof-site")
#+end_src

*** Column Marker
:PROPERTIES:
:CUSTOM_ID: Column-Marker
:END:

(  Maybe a hook would be better? Much better...? )

Have a thin line to the right to ensure I don't write ‚Äúoff the page‚Äù.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package fill-column-indicator)
(define-globalized-minor-mode my-fci-global-mode fci-mode
  (lambda () (set-fill-column 90) (fci-mode 't)
))
(my-fci-global-mode 1)
#+END_SRC

There are issues with making things global.
In this case, exporting to html produces curious symbols
thereby prompting ~my-org-html-export-to-html~ below to
take care of this.

*** My global visual line mode                             :no_longer_used:
:PROPERTIES:
:CUSTOM_ID: My-global-visual-line-mode
:END:

#+BEGIN_SRC emacs-lisp :tangle no
(define-globalized-minor-mode my-visual-line-global-mode visual-line-mode
  (lambda ()

    ;; Wrap words in all buffers
    (visual-line-mode t)

))
(my-visual-line-global-mode 1)
#+END_SRC
# What I like about truncate-lines versus visual-line-mode is that the former doesn‚Äôt split
# on word boundaries and adds symbols to the fringe.
# (set-default 'truncate-lines t)
*** theme magic
[[https://github.com/jcaw/theme-magic][Theme-magic]] looks nice, in theory, but I've not found it to be useful, for me.
#+BEGIN_SRC emacs-lisp :tangle no
;; Automatically propagate Emacs theme changes to OS
(use-package theme-magic)
;; (shell-command "pip3 install pywal")
(theme-magic-export-theme-mode)
#+END_SRC

* COMMENT TODO ‚îÄPushing to blog‚îÄ
:PROPERTIES:
:CUSTOM_ID: COMMENT-TODO-‚îÄPushing-to-blog‚îÄ
:END:

C-c C-c this snippet to export to blog.
#+NAME: publish-to-blog
#+BEGIN_SRC emacs-lisp :results none
;; No code execution on export
;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
;;
(setq org-export-use-babel nil)

;; Different Emacs logos for blog and github.
;; (toggle to-github? nil (my/publish-to-blog 'yes 'local))
(-let [to-github? nil] (my/publish-to-blog))
#+END_SRC
* COMMENT footer
:PROPERTIES:
:CUSTOM_ID: COMMENT-footer
:END:

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "enable making init and readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (local-set-key (kbd "<f9>") (lambda () (interactive) (org-babel-goto-named-src-block "publish-to-blog") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# compile-command:  (progn (org-babel-tangle) (byte-compile-file "~/.emacs.d/init.el") (load-file "~/.emacs.d/init.el"))
# End:
